#include <vector>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <cstring>
#include "STM.h"
#include "MDCUSBDevice.h"
#include "Toastbox/RuntimeError.h"
#include "Toastbox/NumForStr.h"
#include "Toastbox/DurationString.h"
#include "Toastbox/String.h"
#include "Toastbox/Cast.h"
#include "ChecksumFletcher32.h"
#include "Img.h"
#include "SD.h"
#include "ImgSD.h"
#include "MSP.h"
#include "ELF32Binary.h"
#include "Time.h"
#include "TimeAdjustment.h"
#include "TimeString.h"
#include "Clock.h"
#include "date/date.h"
#include "date/tz.h"

using CmdStr = std::string;

// Common Commands
const CmdStr ResetCmd               = "Reset";
const CmdStr StatusGetCmd           = "StatusGet";
const CmdStr BatteryStatusGetCmd    = "BatteryStatusGet";
const CmdStr BootloaderInvokeCmd    = "BootloaderInvoke";
const CmdStr LEDSetCmd              = "LEDSet";

// STMLoader Commands
const CmdStr STMRAMWriteCmd         = "STMRAMWrite";
const CmdStr STMRAMWriteLegacyCmd   = "STMRAMWriteLegacy";

// STMApp Commands
const CmdStr STMFlashWriteCmd       = "STMFlashWrite";
const CmdStr HostModeSetCmd         = "HostModeSet";
const CmdStr ICERAMWriteCmd         = "ICERAMWrite";
const CmdStr ICEFlashReadCmd        = "ICEFlashRead";
const CmdStr ICEFlashWriteCmd       = "ICEFlashWrite";
const CmdStr MSPStateReadCmd        = "MSPStateRead";
const CmdStr MSPStateWriteCmd       = "MSPStateWrite";
const CmdStr MSPTimeGetCmd          = "MSPTimeGet";
const CmdStr MSPTimeInitCmd         = "MSPTimeInit";
const CmdStr MSPTimeAdjustCmd       = "MSPTimeAdjust";
const CmdStr MSPSBWReadCmd          = "MSPSBWRead";
const CmdStr MSPSBWWriteCmd         = "MSPSBWWrite";
const CmdStr MSPSBWEraseCmd         = "MSPSBWErase";
const CmdStr MSPSBWDebugLogCmd      = "MSPSBWDebugLog";
const CmdStr SDReadCmd              = "SDRead";
const CmdStr SDEraseCmd             = "SDErase";
const CmdStr ImgReadFullCmd         = "ImgReadFull";
const CmdStr ImgReadThumbCmd        = "ImgReadThumb";
const CmdStr ImgCaptureCmd          = "ImgCapture";

static void printUsage() {
    using namespace std;
    cout << "MDCUtil commands:\n";
    
    // Common Commands
    cout << "  " << ResetCmd                << "\n";
    cout << "  " << StatusGetCmd            << "\n";
    cout << "  " << BatteryStatusGetCmd     << "\n";
    cout << "  " << BootloaderInvokeCmd     << "\n";
    cout << "  " << LEDSetCmd               << " <idx> <0/1>\n";
    
    // STMLoader Commands
    cout << "  " << STMRAMWriteCmd          << " <file>\n";
    cout << "  " << STMRAMWriteLegacyCmd    << " <file>\n";
    
    // STMApp Commands
    cout << "  " << STMFlashWriteCmd        << " <file>\n";
    
    cout << "  " << HostModeSetCmd          << " <0/1>\n";
    
    cout << "  " << ICERAMWriteCmd          << " <file>\n";
    cout << "  " << ICEFlashReadCmd         << " <addr> <len>\n";
    cout << "  " << ICEFlashWriteCmd        << " <file>\n";
    
    cout << "  " << MSPStateReadCmd         << "\n";
    cout << "  " << MSPStateWriteCmd        << "\n";
    cout << "  " << MSPTimeGetCmd           << "\n";
    cout << "  " << MSPTimeInitCmd          << "\n";
    cout << "  " << MSPTimeAdjustCmd        << "\n";
    
    cout << "  " << MSPSBWReadCmd           << " <addr> <len>\n";
    cout << "  " << MSPSBWWriteCmd          << " <file>\n";
    cout << "  " << MSPSBWEraseCmd          << "\n";
    cout << "  " << MSPSBWDebugLogCmd       << "\n";
    
    cout << "  " << SDReadCmd               << " <addr> <blockcount> <output>\n";
    cout << "  " << SDEraseCmd              << " <addr> <blockcount> <output>\n";
    
    cout << "  " << ImgReadFullCmd          << " <id> <output>\n";
    cout << "  " << ImgReadThumbCmd         << " <id> <output>\n";
    cout << "  " << ImgCaptureCmd           << " <output.cfa>\n";
    
    cout << "\n";
}

struct Args {
    CmdStr cmd = "";
    
    struct {
        uint8_t idx = 0;
        uint8_t on = 0;
    } LEDSet = {};
    
    struct {
        std::string filePath;
    } STMRAMWrite = {};
    
    struct {
        std::string filePath;
    } STMRAMWriteLegacy = {};
    
    struct {
        std::string filePath;
    } STMFlashWrite = {};
    
    struct {
        bool en;
    } HostModeSet = {};
    
    struct {
        std::string filePath;
    } ICERAMWrite = {};
    
    struct {
        uintptr_t addr = 0;
        size_t len = 0;
    } ICEFlashRead = {};
    
    struct {
        std::string filePath;
    } ICEFlashWrite = {};
    
    struct {
        uintptr_t addr = 0;
        size_t len = 0;
    } MSPSBWRead = {};
    
    struct {
        std::string filePath;
    } MSPSBWWrite = {};
    
    struct {
        SD::Block addr = 0;
        SD::Block count = 0;
        std::string filePath;
    } SDRead = {};
    
    struct {
        SD::Block addr = 0;
        SD::Block count = 0;
    } SDErase = {};
    
    struct {
        Img::Id id = 0;
        std::string filePath;
    } ImgReadFull = {};
    
    struct {
        Img::Id id = 0;
        std::string filePath;
    } ImgReadThumb = {};
    
    struct {
        std::string filePath;
    } ImgCapture = {};
};

static std::string lower(const std::string& str) {
    std::string r = str;
    std::transform(r.begin(), r.end(), r.begin(), ::tolower);
    return r;
}

static Args parseArgs(int argc, const char* argv[]) {
    using namespace Toastbox;
    
    std::vector<std::string> strs;
    for (int i=0; i<argc; i++) strs.push_back(argv[i]);
    
    Args args;
    if (strs.size() < 1) throw std::runtime_error("no command specified");
    args.cmd = lower(strs[0]);
    
    if (args.cmd == lower(ResetCmd)) {
    
    } else if (args.cmd == lower(StatusGetCmd)) {
    
    } else if (args.cmd == lower(BatteryStatusGetCmd)) {
    
    } else if (args.cmd == lower(BootloaderInvokeCmd)) {
    
    } else if (args.cmd == lower(LEDSetCmd)) {
        if (strs.size() < 3) throw std::runtime_error("missing argument: LED index/state");
        IntForStr(args.LEDSet.idx, strs[1]);
        IntForStr(args.LEDSet.on, strs[2]);
    
    } else if (args.cmd == lower(STMRAMWriteCmd)) {
        if (strs.size() < 2) throw std::runtime_error("missing argument: file path");
        args.STMRAMWrite.filePath = strs[1];
    
    } else if (args.cmd == lower(STMRAMWriteLegacyCmd)) {
        if (strs.size() < 2) throw std::runtime_error("missing argument: file path");
        args.STMRAMWriteLegacy.filePath = strs[1];
    
    } else if (args.cmd == lower(STMFlashWriteCmd)) {
        if (strs.size() < 2) throw std::runtime_error("missing argument: file path");
        args.STMFlashWrite.filePath = strs[1];
    
    } else if (args.cmd == lower(HostModeSetCmd)) {
        if (strs.size() < 2) throw std::runtime_error("missing argument: host mode state");
        IntForStr(args.HostModeSet.en, strs[1]);
    
    } else if (args.cmd == lower(ICERAMWriteCmd)) {
        if (strs.size() < 2) throw std::runtime_error("missing argument: file path");
        args.ICERAMWrite.filePath = strs[1];
    
    } else if (args.cmd == lower(ICEFlashReadCmd)) {
        if (strs.size() < 3) throw std::runtime_error("missing argument: address/length");
        IntForStr(args.ICEFlashRead.addr, strs[1]);
        IntForStr(args.ICEFlashRead.len, strs[2]);
    
    } else if (args.cmd == lower(ICEFlashWriteCmd)) {
        if (strs.size() < 2) throw std::runtime_error("missing argument: file path");
        args.ICEFlashWrite.filePath = strs[1];
    
    } else if (args.cmd == lower(MSPStateReadCmd)) {
    
    } else if (args.cmd == lower(MSPStateWriteCmd)) {
    
    } else if (args.cmd == lower(MSPTimeGetCmd)) {
    
    } else if (args.cmd == lower(MSPTimeInitCmd)) {
    
    } else if (args.cmd == lower(MSPTimeAdjustCmd)) {
    
    } else if (args.cmd == lower(MSPSBWReadCmd)) {
        if (strs.size() < 3) throw std::runtime_error("missing argument: address/length");
        IntForStr(args.MSPSBWRead.addr, strs[1]);
        IntForStr(args.MSPSBWRead.len, strs[2]);
    
    } else if (args.cmd == lower(MSPSBWWriteCmd)) {
        if (strs.size() < 2) throw std::runtime_error("missing argument: file path");
        args.MSPSBWWrite.filePath = strs[1];
    
    } else if (args.cmd == lower(MSPSBWEraseCmd)) {
    
    } else if (args.cmd == lower(MSPSBWDebugLogCmd)) {
    
    } else if (args.cmd == lower(SDReadCmd)) {
        if (strs.size() < 4) throw std::runtime_error("missing argument: address/length/file");
        IntForStr(args.SDRead.addr, strs[1]);
        IntForStr(args.SDRead.count, strs[2]);
        args.SDRead.filePath = strs[3];
    
    } else if (args.cmd == lower(SDEraseCmd)) {
        if (strs.size() < 3) throw std::runtime_error("missing argument: address/length");
        IntForStr(args.SDErase.addr, strs[1]);
        IntForStr(args.SDErase.count, strs[2]);
    
    } else if (args.cmd == lower(ImgReadFullCmd)) {
        if (strs.size() < 3) throw std::runtime_error("missing argument: id/file path");
        IntForStr(args.ImgReadFull.id, strs[1]);
        args.ImgReadFull.filePath = strs[2];
    
    } else if (args.cmd == lower(ImgReadThumbCmd)) {
        if (strs.size() < 3) throw std::runtime_error("missing argument: id/file path");
        IntForStr(args.ImgReadThumb.id, strs[1]);
        args.ImgReadThumb.filePath = strs[2];
    
    } else if (args.cmd == lower(ImgCaptureCmd)) {
        if (strs.size() < 2) throw std::runtime_error("missing argument: file path");
        args.ImgCapture.filePath = strs[1];
    
    } else {
        throw std::runtime_error("invalid command");
    }
    
    return args;
}

static void Reset(const Args& args, MDCUSBDevice& device) {
    printf("Resetting...\n");
    device.reset();
    printf("-> OK\n\n");
}

static const char* _StringForStatusMode(const STM::Status::Mode mode) {
    using namespace STM;
    switch (mode) {
    case STM::Status::Mode::STMLoader:  return "STMLoader";
    case STM::Status::Mode::STMApp:     return "STMApp";
    default:                            return "<Invalid>";
    }
}

static void StatusGet(const Args& args, MDCUSBDevice& device) {
    using namespace STM;
    Status status = device.statusGet();
    printf("Status:\n");
    printf("  header:\n");
    printf("    magic:    0x%08jx\n", (uintmax_t)status.header.magic);
    printf("    version:  %ju\n", (uintmax_t)status.header.version);
    printf("  mspVersion: %ju\n", (uintmax_t)status.mspVersion);
    printf("  mode:       %s\n", _StringForStatusMode(status.mode));
    printf("\n");
}

static const char* _StringForChargeStatus(MSP::ChargeStatus status) {
    using namespace MSP;
    switch (status) {
    case ChargeStatus::Invalid:  return "invalid";
    case ChargeStatus::Shutdown: return "shutdown";
    case ChargeStatus::Underway: return "underway";
    case ChargeStatus::Complete: return "complete";
    }
    abort();
}

static std::string _StringForBatteryLevel(MSP::BatteryLevelMv level) {
    using namespace STM;
    
    const MSP::BatteryLevel levelLinear = MSP::BatteryLevelLinearize(level);
    if (levelLinear == MSP::BatteryLevelMvInvalid) return "invalid";
    
    const uint32_t percent = (((uint32_t)levelLinear-MSP::BatteryLevelMin)*100) / (MSP::BatteryLevelMax-MSP::BatteryLevelMin);
    return std::to_string(percent) + "%";
}

static void BatteryStatusGet(const Args& args, MDCUSBDevice& device) {
    using namespace STM;
    BatteryStatus status = device.batteryStatusGet();
    
    printf("Battery status:\n");
    printf("  Charge status: %s\n", _StringForChargeStatus(status.chargeStatus));
    printf("  Battery level: %s (%ju mv)\n", _StringForBatteryLevel(status.level).c_str(), (uintmax_t)status.level);
    printf("\n");
}

static void BootloaderInvoke(const Args& args, MDCUSBDevice& device) {
    device.bootloaderInvoke();
}

static void LEDSet(const Args& args, MDCUSBDevice& device) {
    device.ledSet(args.LEDSet.idx, args.LEDSet.on);
}

static void STMRAMWrite(const Args& args, MDCUSBDevice& device) {
    ELF32Binary elf(args.STMRAMWrite.filePath.c_str());
    
    elf.enumerateLoadableSections([&](uint32_t paddr, uint32_t vaddr, const void* data,
    size_t size, const char* name) {
        printf("STMRAMWrite: Writing %12s @ 0x%08jx    size: 0x%08jx    vaddr: 0x%08jx\n",
            name, (uintmax_t)paddr, (uintmax_t)size, (uintmax_t)vaddr);
        
        device.stmRAMWrite(paddr, data, size);
    });
    
    // Reset the device, triggering it to load the program we just wrote
    printf("STMRAMWrite: Resetting device\n");
    device.stmReset(elf.entryPointAddr());
}

static void STMRAMWriteLegacy(const Args& args, MDCUSBDevice& device) {
    ELF32Binary elf(args.STMRAMWriteLegacy.filePath.c_str());
    
    elf.enumerateLoadableSections([&](uint32_t paddr, uint32_t vaddr, const void* data,
    size_t size, const char* name) {
        printf("STMRAMWriteLegacy: Writing %12s @ 0x%08jx    size: 0x%08jx    vaddr: 0x%08jx\n",
            name, (uintmax_t)paddr, (uintmax_t)size, (uintmax_t)vaddr);
        
        device.stmRAMWriteLegacy(paddr, data, size);
    });
    
    // Reset the device, triggering it to load the program we just wrote
    printf("STMRAMWriteLegacy: Resetting device\n");
    device.stmReset(elf.entryPointAddr());
}

static void STMFlashWrite(const Args& args, MDCUSBDevice& device) {
    ELF32Binary elf(args.STMFlashWrite.filePath.c_str());
    
    device.stmFlashWriteInit();
    
    elf.enumerateLoadableSections([&](uint32_t paddr, uint32_t vaddr, const void* data,
    size_t size, const char* name) {
        printf("STMFlashWrite: Writing %12s @ 0x%08jx    size: 0x%08jx    vaddr: 0x%08jx\n",
            name, (uintmax_t)paddr, (uintmax_t)size, (uintmax_t)vaddr);
        
        device.stmFlashWrite(paddr, data, size);
    });
    
    // Invoke the bootloader, triggering it to load the program we just wrote
    printf("STMFlashWrite: invoking bootloader\n");
    device.bootloaderInvoke();
}

static void HostModeSet(const Args& args, MDCUSBDevice& device) {
    printf("HostModeSet: %d\n", (int)args.HostModeSet.en);
    device.hostModeSet(args.HostModeSet.en);
}

static void ICERAMWrite(const Args& args, MDCUSBDevice& device) {
    Toastbox::Mmap mmap(args.ICERAMWrite.filePath.c_str());
    
    // Send the ICE40 binary
    printf("ICERAMWrite: Writing %ju bytes\n", (uintmax_t)mmap.len());
    device.iceRAMWrite(mmap.data(), mmap.len());
}

static void ICEFlashRead(const Args& args, MDCUSBDevice& device) {
    printf("Reading [0x%08jx,0x%08jx):\n",
        (uintmax_t)args.ICEFlashRead.addr,
        (uintmax_t)(args.ICEFlashRead.addr+args.ICEFlashRead.len)
    );
    
    auto buf = std::make_unique<uint8_t[]>(args.ICEFlashRead.len);
    device.iceFlashRead(args.ICEFlashRead.addr, buf.get(), args.ICEFlashRead.len);
    
    for (size_t i=0; i<args.ICEFlashRead.len; i++) {
        printf("%02jx ", (uintmax_t)buf[i]);
    }
    
    printf("\n");
}

static void ICEFlashWrite(const Args& args, MDCUSBDevice& device) {
    Toastbox::Mmap mmap(args.ICEFlashWrite.filePath.c_str());
    
    const size_t len = mmap.len();
    
    // Send the ICE40 binary
    printf("ICEFlashWrite: Writing %ju bytes\n", (uintmax_t)mmap.len());
    device.iceFlashWrite(0, mmap.data(), len);
    
    // Send the ICE40 binary
    printf("ICEFlashWrite: Verifying %ju bytes\n", (uintmax_t)mmap.len());
    auto buf = std::make_unique<uint8_t[]>(len);
    device.iceFlashRead(0, buf.get(), len);
    if (memcmp(mmap.data(), buf.get(), len)) {
        constexpr const char* ReadBackDataFilename = "ICEFlashWrite-ReadBack.bin";
        std::ofstream f;
        f.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        f.open(ReadBackDataFilename);
        f.write((char*)buf.get(), len);
        throw Toastbox::RuntimeError("data written doesn't match data read (wrote to %s)", ReadBackDataFilename);
    }
}

static const char* _StringForRepeatType(MSP::Repeat::Type x) {
    using X = MSP::Repeat::Type;
    switch (x) {
    case X::Never:  return "Never";  break;
    case X::Daily:  return "Daily";  break;
    case X::Weekly: return "Weekly"; break;
    case X::Yearly: return "Yearly"; break;
    }
    return "unknown";
}

static const char* _StringForTriggerEventType(MSP::Triggers::Event::Type x) {
    using X = MSP::Triggers::Event::Type;
    switch (x) {
    case X::TimeTrigger:  return "TimeTrigger";
    case X::MotionEnable: return "MotionEnable";
    case X::DST:          return "DST";
    }
    return "unknown";
}

static const char* _StringForResetType(MSP::Reset::Type x) {
    switch (x) {
    case MSP::Reset::Type::Reset:         return "reset";
    case MSP::Reset::Type::Abort:         return "abort";
    case MSP::Reset::Type::StackOverflow: return "stack overflow";
    }
    return "unknown";
}

static const char* _StringForResetReason(uint16_t x) {
    switch (x) {
    case 0x0000: return "NONE";
    case 0x0002: return "BOR";
    case 0x0004: return "RSTNMI";
    case 0x0006: return "DOBOR";
    case 0x0008: return "LPM5WU";
    case 0x000A: return "SECYV";
    case 0x000C: return "RES12";
    case 0x000E: return "SVSHIFG";
    case 0x0010: return "RES16";
    case 0x0012: return "RES18";
    case 0x0014: return "DOPOR";
    case 0x0016: return "WDTTO";
    case 0x0018: return "WDTKEY";
    case 0x001A: return "FRCTLPW";
    case 0x001C: return "UBDIFG";
    case 0x001E: return "PERF";
    case 0x0020: return "PMMPW";
    case 0x0024: return "FLLUL";
    }
    return "unknown";
}

static float _SecondsForTicks(uint32_t ticks) {
    // Check our assumption that Time::TicksFreq is an integer
    static_assert(Time::TicksFreq::den == 1);
    return (float)ticks / Time::TicksFreq::num;
}

static std::filesystem::path _MSPAppPath() {
    using namespace std::filesystem;
    path home = getenv("HOME");
    return home / "repos/MDCCode/Code/MSP430/MSPApp/Release/MSPApp.out";
}

static std::string _Run(const char* cmd) {
    std::string r;
    FILE* p = popen(cmd, "r");
    if (!p) throw std::runtime_error("popen failed");
    
    char tmp[128];
    while (fgets(tmp, sizeof(tmp), p)) r += tmp;
    
    const int ir = pclose(p);
    if (!WIFEXITED(ir) || WEXITSTATUS(ir)) throw Toastbox::RuntimeError("command failed: %s", cmd);
    
    return r;
}

static std::string __MSPLineForAddr(uint16_t addr) {
    const std::filesystem::path mspAppPath = _MSPAppPath();
    char cmd[256];
    const int ir = snprintf(cmd, sizeof(cmd), "dwarfdump %s --lookup 0x%jx 2>&1", mspAppPath.c_str(), (uintmax_t)addr);
    if (ir<0 || ir>=sizeof(cmd)) throw std::runtime_error("snprintf failed");
    auto lines = Toastbox::String::Split(Toastbox::String::Trim(_Run(cmd)), "\n");
    if (lines.empty()) throw std::runtime_error("dwarfdump returned no output");
    return lines.back();
}

static std::string _MSPLineForAddr(uint16_t addr) {
    try {
        return __MSPLineForAddr(addr);
    } catch (const std::exception& e) {
        return std::string("address lookup failed: ") + e.what();
    }
}

static void MSPStateRead(const Args& args, MDCUSBDevice& device) {
    // Read the device state
    MSP::State state = device.mspStateRead();
    
    printf(         "header\n");
    printf(         "  magic:                   0x%08jx\n",             (uintmax_t)state.header.magic);
    printf(         "  version:                 0x%04jx\n",             (uintmax_t)state.header.version);
    printf(         "  length:                  0x%04jx\n",             (uintmax_t)state.header.length);
    printf(         "\n");
    
    printf(         "sd\n");
    printf(         "  cardId\n");
    printf(         "    manufacturerId:        0x%02jx\n",             (uintmax_t)state.sd.cardId.manufacturerId);
    printf(         "    oemId:                 0x%02jx\n",             (uintmax_t)state.sd.cardId.oemId);
    printf(         "    productName:           %c%c%c%c%c\n",          state.sd.cardId.productName[0],
                                                                        state.sd.cardId.productName[1],
                                                                        state.sd.cardId.productName[2],
                                                                        state.sd.cardId.productName[3],
                                                                        state.sd.cardId.productName[4]);
    printf(         "    productRevision:       0x%02jx\n",             (uintmax_t)state.sd.cardId.productRevision);
    printf(         "    productSerialNumber:   0x%08jx\n",             (uintmax_t)state.sd.cardId.productSerialNumber);
    printf(         "    manufactureDate:       0x%04jx\n",             (uintmax_t)state.sd.cardId.manufactureDate);
    printf(         "    crc:                   0x%02jx\n",             (uintmax_t)state.sd.cardId.crc);
    
    printf(         "  imgCap:                  %ju\n",                 (uintmax_t)state.sd.imgCap);
    printf(         "  baseFull:                %ju\n",                 (uintmax_t)state.sd.baseFull);
    printf(         "  baseThumb:               %ju\n",                 (uintmax_t)state.sd.baseThumb);
    
    printf(         "  imgRingBufs[0]\n");
    printf(         "    buf\n");
    printf(         "      id:                  %ju\n",                 (uintmax_t)state.sd.imgRingBufs[0].buf.id);
    printf(         "      idx:                 %ju\n",                 (uintmax_t)state.sd.imgRingBufs[0].buf.idx);
    printf(         "    valid:                 %ju\n",                 (uintmax_t)state.sd.imgRingBufs[0].valid);
    
    printf(         "  imgRingBufs[1]\n");
    printf(         "    buf\n");
    printf(         "      id:                  %ju\n",                 (uintmax_t)state.sd.imgRingBufs[1].buf.id);
    printf(         "      idx:                 %ju\n",                 (uintmax_t)state.sd.imgRingBufs[1].buf.idx);
    printf(         "    valid:                 %ju\n",                 (uintmax_t)state.sd.imgRingBufs[1].valid);
    printf(         "\n");
    
    printf(         "settings\n");
    printf(         "  triggers\n");
    
    const auto& triggers = state.settings.triggers;
    
    printf(         "    event\n");
    for (auto it=std::begin(triggers.repeatEvent); it!=std::begin(triggers.repeatEvent)+triggers.repeatEventCount; it++) {
        printf(     "      #%ju\n",                                     (uintmax_t)(&*it-triggers.repeatEvent));
        printf(     "        time:                  %s\n",              Time::StringForTimeInstant(it->time).c_str());
        printf(     "        type:                  %s\n",              _StringForTriggerEventType(it->type));
        printf(     "        repeat\n");
        printf(     "          type:                %s\n",              _StringForRepeatType(it->repeat.type));
        printf(     "          arg:                 0x%jx\n",           (uintmax_t)it->repeat.Daily.interval);
        printf(     "        idx:                   %ju\n",             (uintmax_t)it->idx);
    }
    
    printf(         "    timeTrigger\n");
    for (auto it=std::begin(triggers.timeTrigger); it!=std::begin(triggers.timeTrigger)+triggers.timeTriggerCount; it++) {
        printf(     "      #%ju\n",                                     (uintmax_t)(&*it-triggers.timeTrigger));
        printf(     "        capture\n");
        printf(     "          delayTicks:          %ju (%.1f)\n",      (uintmax_t)it->capture.delayTicks, _SecondsForTicks(it->capture.delayTicks));
        printf(     "          count:               %ju\n",             (uintmax_t)it->capture.count);
        printf(     "          ledFlash:            %ju\n",             (uintmax_t)it->capture.ledFlash);
    }
    
    printf(         "    motionTrigger\n");
    for (auto it=std::begin(triggers.motionTrigger); it!=std::begin(triggers.motionTrigger)+triggers.motionTriggerCount; it++) {
        printf(     "      #%ju\n",                                     (uintmax_t)(&*it-triggers.motionTrigger));
        printf(     "        capture\n");
        printf(     "          delayTicks:          %ju (%.1f)\n",      (uintmax_t)it->capture.delayTicks, _SecondsForTicks(it->capture.delayTicks));
        printf(     "          count:               %ju\n",             (uintmax_t)it->capture.count);
        printf(     "          ledFlash:            %ju\n",             (uintmax_t)it->capture.ledFlash);
        printf(     "        count:                 %ju\n",             (uintmax_t)it->count);
        printf(     "        durationTicks:         %ju (%.1f)\n",      (uintmax_t)it->durationTicks, _SecondsForTicks(it->durationTicks));
        printf(     "        suppressTicks:         %ju (%.1f)\n",      (uintmax_t)it->suppressTicks, _SecondsForTicks(it->suppressTicks));
    }
    
    printf(         "    buttonTrigger\n");
    for (auto it=std::begin(triggers.buttonTrigger); it!=std::begin(triggers.buttonTrigger)+triggers.buttonTriggerCount; it++) {
        printf(     "      #%ju\n",                                     (uintmax_t)(&*it-triggers.buttonTrigger));
        printf(     "        capture\n");
        printf(     "          delayTicks:          %ju (%.1f)\n",      (uintmax_t)it->capture.delayTicks, _SecondsForTicks(it->capture.delayTicks));
        printf(     "          count:               %ju\n",             (uintmax_t)it->capture.count);
        printf(     "          ledFlash:            %ju\n",             (uintmax_t)it->capture.ledFlash);
    }
    
    printf(         "    source\n");
    for (auto it=std::begin(triggers.source); it!=std::end(triggers.source);) {
        printf(     "      ");
        for (int i=0; i<16 && it!=std::end(triggers.source); i++, it++) {
            printf("%02jx ", (uintmax_t)*it);
        }
        printf("\n");
    }
    printf(         "\n");
    
    printf(         "resets\n");
    size_t i = 0;
    for (const auto& reset : state.resets) {
        if (!reset.count) break;
        printf(     "  #%ju\n",                                         (uintmax_t)i);
        printf(     "    type:                  0x%02jx (%s)\n",        (uintmax_t)reset.type, _StringForResetType(reset.type));
        
        switch (reset.type) {
        case MSP::Reset::Type::Reset:
            printf( "    reason:                0x%04jx (%s)\n",        (uintmax_t)reset.ctx.Reset.reason, _StringForResetReason(reset.ctx.Reset.reason));
            break;
        case MSP::Reset::Type::Abort:
            printf( "    addr:                  0x%04jx [ %s ]\n",      (uintmax_t)reset.ctx.Abort.addr, _MSPLineForAddr(reset.ctx.Abort.addr).c_str());
            break;
        case MSP::Reset::Type::StackOverflow:
            printf( "    taskIdx:               %ju\n",                 (uintmax_t)reset.ctx.StackOverflow.taskIdx);
            break;
        }
        printf(     "    count:                 %ju\n",                 (uintmax_t)reset.count);
        i++;
    }
    printf(         "\n");
}

static void MSPStateWrite(const Args& args, MDCUSBDevice& device) {
    throw Toastbox::RuntimeError("unimplemented");
}

static void MSPTimeGet(const Args& args, MDCUSBDevice& device) {
    using namespace std::chrono;
    using namespace date;
    
    std::cout << "MSPTimeGet:\n";
    const MSP::TimeState ts = device.mspTimeGet();
    std::cout << Time::StringForTimeState(ts);
}

static void MSPTimeInit(const Args& args, MDCUSBDevice& device) {
//    struct [[gnu::packed]] TimeState {
//        Time::Instant start;
//        Time::Instant time;
//        struct [[gnu::packed]] {
//            int32_t value;          // Current adjustment to `time`
//            Time::Ticks32 counter;  // Counts ticks until `counter >= `interval`
//            Time::Ticks32 interval; // Interval upon which we perform `value += delta`
//            int16_t delta;          // Amount to add to `value` when `counter >= interval`
//        } adjustment;
//    };
    
    std::cout << "MSPTimeInit:\n\n";
    const MSP::TimeState ts = device.mspTimeInit();
    std::cout << Time::StringForTimeState(ts) << "\n";
}

static void MSPTimeAdjust(const Args& args, MDCUSBDevice& device) {
    std::cout << "MSPTimeAdjust:\n\n";
    device.mspTimeAdjust();
}

static void MSPSBWRead(const Args& args, MDCUSBDevice& device) {
    device.mspLock();
    device.mspSBWConnect();
    device.mspSBWHalt();
    
    printf("Reading [0x%08jx,0x%08jx):\n",
        (uintmax_t)args.MSPSBWRead.addr,
        (uintmax_t)(args.MSPSBWRead.addr+args.MSPSBWRead.len)
    );
    
    auto buf = std::make_unique<uint8_t[]>(args.MSPSBWRead.len);
    device.mspSBWRead(args.MSPSBWRead.addr, buf.get(), args.MSPSBWRead.len);
    
    for (size_t i=0; i<args.MSPSBWRead.len; i++) {
        printf("%02jx ", (uintmax_t)buf[i]);
    }
    
    printf("\n");
    
    device.mspSBWReset();
    device.mspSBWDisconnect();
    device.mspUnlock();
}

static void MSPSBWWrite(const Args& args, MDCUSBDevice& device) {
    ELF32Binary elf(args.MSPSBWWrite.filePath.c_str());
    
    device.mspLock();
    device.mspSBWConnect();
    device.mspSBWHalt();
    
    // Write the data
    elf.enumerateLoadableSections([&](uint32_t paddr, uint32_t vaddr, const void* data,
    size_t size, const char* name) {
        printf("MSPSBWWrite: Writing %22s @ 0x%04jx    size: 0x%04jx    vaddr: 0x%04jx\n",
            name, (uintmax_t)paddr, (uintmax_t)size, (uintmax_t)vaddr);
        
        device.mspSBWWrite(paddr, data, size);
    });
    
    // Read back data and compare with what we expect
    elf.enumerateLoadableSections([&](uint32_t paddr, uint32_t vaddr, const void* data,
    size_t size, const char* name) {
        printf("MSPSBWWrite: Verifying %s @ 0x%jx [size: 0x%jx]\n",
            name, (uintmax_t)paddr, (uintmax_t)size);
        
        auto buf = std::make_unique<uint8_t[]>(size);
        device.mspSBWRead(paddr, buf.get(), size);
        
        if (memcmp(data, buf.get(), size)) {
            throw Toastbox::RuntimeError("section doesn't match: %s", name);
        }
    });
    
    device.mspSBWReset();
    device.mspSBWDisconnect();
    device.mspUnlock();
}

static void MSPSBWErase(const Args& args, MDCUSBDevice& device) {
    std::cout << "MSPSBWErase\n";
    device.mspLock();
    device.mspSBWErase();
    device.mspUnlock();
    std::cout << "-> OK\n\n";
}

static size_t _Width(MSP::DebugLogPacket::Type x) {
    using X = MSP::DebugLogPacket::Type;
    switch (x) {
    case X::Dec16: return 2;
    case X::Dec32: return 4;
    case X::Dec64: return 8;
    case X::Hex16: return 2;
    case X::Hex32: return 4;
    case X::Hex64: return 8;
    default:       return 0;
    }
}

static void _Print(MSP::DebugLogPacket::Type t, uint64_t x) {
    using X = MSP::DebugLogPacket::Type;
    switch (t) {
    case X::Dec16:
    case X::Dec32:
    case X::Dec64:
        printf("%ju", (uintmax_t)x);
        return;
    case X::Hex16:
        printf("0x%04jx", (uintmax_t)x);
        return;
    case X::Hex32:
        printf("0x%08jx", (uintmax_t)x);
        return;
    case X::Hex64:
        printf("0x%016jx", (uintmax_t)x);
        return;
    default:
        abort();
    }
}

static void MSPSBWDebugLog(const Args& args, MDCUSBDevice& device) {
    using DebugLogPacket = MSP::DebugLogPacket;
    DebugLogPacket log[Toastbox::USB::Endpoint::MaxPacketSizeBulk / sizeof(DebugLogPacket)];
    
    std::cout << "MSPSBWDebugLog\n";
//    device.mspLock();
    device.mspSBWConnect();
    device.mspSBWDebugLog();
    std::cout << "-> OK:\n\n";
    
    struct {
        DebugLogPacket::Type type = DebugLogPacket::Type::Chars;
        size_t off = 0;
        union {
            uint8_t u8[8];
            uint64_t u64 = 0;
        };
    } state;
    
    for (;;) {
        const size_t count = device.readout(log, sizeof(log)) / sizeof(DebugLogPacket);
        for (size_t i=0; i<count; i++) {
            DebugLogPacket& p = log[i];
            
            // Chars state
            if (state.type == DebugLogPacket::Type::Chars) {
                // Chars packet: print newline
                if (p.type == DebugLogPacket::Type::Chars) {
                    printf("\n");
                
                // DecXXX/HexXXX packet: enter the Int state
                } else if (_Width(p.type)) {
                    printf("\n");
                    state = { .type = p.type };
                
                // Chars payload packet: print characters
                } else {
                    for (uint8_t c : p.u8) {
                        if (!c) break;
                        std::cout << (char)c;
                    }
                }
                
            // Int state
            } else {
                state.u8[state.off+0] = p.u8[0];
                state.u8[state.off+1] = p.u8[1];
                state.off += 2;
                if (state.off == _Width(state.type)) {
                    // Done with current int, print it
                    _Print(state.type, state.u64);
                    // Reset state
                    state = {};
                }
            }
        }
        
        std::cout << std::flush;
//        break;
    }
    
    #warning TODO: handle signal to cleanup
    device.reset();
//    device.mspSBWDisconnect();
//    device.mspSBWUnlock();
}

static void SDRead(const Args& args, MDCUSBDevice& device) {
    static_assert(!(SD::BlockLen % Toastbox::USB::Endpoint::MaxPacketSizeBulk));
    const size_t len = (size_t)args.SDRead.count * (size_t)SD::BlockLen;
    
    printf("Sending SDInit command...\n");
    device.sdInit();
    printf("-> OK\n\n");
    
    printf("Sending SDRead command...\n");
    device.sdRead(args.SDRead.addr);
    printf("-> OK\n\n");
    
    printf("Reading data...\n");
    
    auto buf = std::make_unique<uint8_t[]>(len);
    auto timeStart = std::chrono::steady_clock::now();
    device.readout(buf.get(), len);
    auto duration = std::chrono::steady_clock::now() - timeStart;
    auto durationUs = std::chrono::duration_cast<std::chrono::microseconds>(duration);
    const float throughputMBPerSec = (((double)(len*(uint64_t)1000000)) / durationUs.count()) / (1024*1024);
    printf("-> OK (throughput: %.1f MB/sec)\n\n", throughputMBPerSec);
    
    // Write data
    printf("Writing data...\n");
    std::ofstream f;
    f.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    f.open(args.SDRead.filePath.c_str());
    f.write((char*)buf.get(), len);
    printf("-> Wrote %ju blocks (%ju bytes)\n", (uintmax_t)args.SDRead.count, (uintmax_t)len);
}

static void SDErase(const Args& args, MDCUSBDevice& device) {
    if (args.SDErase.count <= 0) throw Toastbox::RuntimeError("invalid block count: %ju", (uintmax_t)args.SDErase.count);
    
    printf("Sending SDInit command...\n");
    device.sdInit();
    printf("-> OK\n\n");
    
    printf("Sending SDErase command...\n");
    device.sdErase(args.SDErase.addr, args.SDErase.addr+args.SDErase.count-1);
    printf("-> OK\n\n");
}

static void _ImgRead(MDCUSBDevice& device, const std::string& filePath, SD::Block block, size_t len) {
    static_assert(!(SD::BlockLen % Toastbox::USB::Endpoint::MaxPacketSizeBulk));
    
    printf("Sending SDInit command...\n");
    device.sdInit();
    printf("-> OK\n\n");
    
    printf("Sending SDRead command...\n");
    device.sdRead(block);
    printf("-> OK\n\n");
    
    printf("Reading data...\n");
    auto buf = std::make_unique<uint8_t[]>(len);
    device.readout(buf.get(), len);
    printf("-> OK\n\n");
    
    // Write data
    printf("Writing data...\n");
    std::ofstream f;
    f.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    f.open(filePath.c_str());
    f.write((char*)buf.get(), len);
    printf("-> OK\n");
}

static void ImgReadFull(const Args& args, MDCUSBDevice& device) {
    const auto& a = args.ImgReadFull;
    const MSP::State mspState = device.mspStateRead();
    const uint32_t idx = a.id % mspState.sd.imgCap;
    const SD::Block block = MSP::SDBlockStart(mspState.sd.baseFull, ImgSD::Full::ImageBlockCount, idx);
    _ImgRead(device, a.filePath, block, ImgSD::Full::ImagePaddedLen);
}

static void ImgReadThumb(const Args& args, MDCUSBDevice& device) {
    const auto& a = args.ImgReadThumb;
    const MSP::State mspState = device.mspStateRead();
    const uint32_t idx = a.id % mspState.sd.imgCap;
    const SD::Block block = MSP::SDBlockStart(mspState.sd.baseThumb, ImgSD::Thumb::ImageBlockCount, idx);
    _ImgRead(device, a.filePath, block, ImgSD::Thumb::ImagePaddedLen);
}

static void ImgCapture(const Args& args, MDCUSBDevice& device) {
    printf("Sending ImgInit command...\n");
    device.imgInit();
    printf("-> OK\n\n");
    
    printf("Sending ImgCapture command...\n");
    STM::ImgCaptureStats stats = device.imgCapture(0, 0, Img::Size::Full);
    printf("-> OK (len: %ju)\n\n", (uintmax_t)stats.len);
    
    printf("Reading image...\n");
    auto img = device.imgReadout(Img::Size::Full);
    printf("-> OK\n\n");
    
    // Write image
    printf("Writing image...\n");
    std::ofstream f;
    f.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    f.open(args.ImgCapture.filePath.c_str());
    f.write((char*)img.get(), Img::Full::ImageLen);
    printf("-> Wrote (len: %ju)\n", (uintmax_t)Img::Full::ImageLen);
}

int main(int argc, const char* argv[]) {
//    const uint8_t data[] = {
//        0x42,0x42,0x00,0x09,0x10,0x05,0x00,0x00,0xbe,0xba,0xfe,0xca,0x00,0x00,0x00,0x00,0xef,0xbe,0xad,0xde,0x00,0x00,0x00,0x00,0x11,0x11,0x22,0x22,0x00,0x00,0x00,0x00,0xff,0x0f,0xfe,0x0f,0xfd,0x0f,0xfc,0x0f,0xfb,0x0f,0xfa,0x0f,0xf9,0x0f,0xf8,0x0f,0xf7,0x0f,0xf6,0x0f,0xf5,0x0f,0xf4,0x0f,0xf3,0x0f,0xf2,0x0f,0xf1,0x0f,0xf0,0x0f,0xef,0x0f,0xee,0x0f,0xed,0x0f,0xec,0x0f,0xeb,0x0f,0xea,0x0f,0xe9,0x0f,0xe8,0x0f,0xe7,0x0f,0xe6,0x0f,0xe5,0x0f,0xe4,0x0f,0xe3,0x0f,0xe2,0x0f,0xe1,0x0f,0xe0,0x0f,0xdf,0x0f,0xde,0x0f,0xdd,0x0f,0xdc,0x0f,0xdb,0x0f,0xda,0x0f,0xd9,0x0f,0xd8,0x0f,0xd7,0x0f,0xd6,0x0f,0xd5,0x0f,0xd4,0x0f,0xd3,0x0f,0xd2,0x0f,0xd1,0x0f,0xd0,0x0f,0xcf,0x0f,0xce,0x0f,0xcd,0x0f,0xcc,0x0f,0xcb,0x0f,0xca,0x0f,0xc9,0x0f,0xc8,0x0f,0xc7,0x0f,0xc6,0x0f,0xc5,0x0f,0xc4,0x0f,0xc3,0x0f,0xc2,0x0f,0xc1,0x0f,0xc0,0x0f,0xbf,0x0f,0xbe,0x0f,0xbd,0x0f,0xbc,0x0f,0xbb,0x0f,0xba,0x0f,0xb9,0x0f,0xb8,0x0f,0xb7,0x0f,0xb6,0x0f,0xb5,0x0f,0xb4,0x0f,0xb3,0x0f,0xb2,0x0f,0xb1,0x0f,0xb0,0x0f,0xaf,0x0f,0xae,0x0f,0xad,0x0f,0xac,0x0f,0xab,0x0f,0xaa,0x0f,0xa9,0x0f,0xa8,0x0f,0xa7,0x0f,0xa6,0x0f,0xa5,0x0f,0xa4,0x0f,0xa3,0x0f,0xa2,0x0f,0xa1,0x0f,0xa0,0x0f,0x9f,0x0f,0x9e,0x0f,0x9d,0x0f,0x9c,0x0f,0x9b,0x0f,0x9a,0x0f,0x99,0x0f,0x98,0x0f,0x97,0x0f,0x96,0x0f,0x95,0x0f,0x94,0x0f,0x93,0x0f,0x92,0x0f,0x91,0x0f,0x90,0x0f,0x8f,0x0f,0x8e,0x0f,0x8d,0x0f,0x8c,0x0f,0x8b,0x0f,0x8a,0x0f,0x89,0x0f,0x88,0x0f,0x87,0x0f,0x86,0x0f,0x85,0x0f,0x84,0x0f,0x83,0x0f,0x82,0x0f,0x81,0x0f,0x80,0x0f,0x7f,0x0f,0x7e,0x0f,0x7d,0x0f,0x7c,0x0f,0x7b,0x0f,0x7a,0x0f,0x79,0x0f,0x78,0x0f,0x77,0x0f,0x76,0x0f,0x75,0x0f,0x74,0x0f,0x73,0x0f,0x72,0x0f,0x71,0x0f,0x70,0x0f,0x6f,0x0f,0x6e,0x0f,0x6d,0x0f,0x6c,0x0f,0x6b,0x0f,0x6a,0x0f,0x69,0x0f,0x68,0x0f,0x67,0x0f,0x66,0x0f,0x65,0x0f,0x64,0x0f,0x63,0x0f,0x62,0x0f,0x61,0x0f,0x60,0x0f,0x5f,0x0f,0x5e,0x0f,0x5d,0x0f,0x5c,0x0f,0x5b,0x0f,0x5a,0x0f,0x59,0x0f,0x58,0x0f,0x57,0x0f,0x56,0x0f,0x55,0x0f,0x54,0x0f,0x53,0x0f,0x52,0x0f,0x51,0x0f,0x50,0x0f,0x4f,0x0f,0x4e,0x0f,0x4d,0x0f,0x4c,0x0f,0x4b,0x0f,0x4a,0x0f,0x49,0x0f,0x48,0x0f,0x47,0x0f,0x46,0x0f,0x45,0x0f,0x44,0x0f,0x43,0x0f,0x42,0x0f,0x41,0x0f,0x40,0x0f,0x3f,0x0f,0x3e,0x0f,0x3d,0x0f,0x3c,0x0f,0x3b,0x0f,0x3a,0x0f,0x39,0x0f,0x38,0x0f,0x37,0x0f,0x36,0x0f,0x35,0x0f,0x34,0x0f,0x33,0x0f,0x32,0x0f,0x31,0x0f,0x30,0x0f,0x2f,0x0f,0x2e,0x0f,0x2d,0x0f,0x2c,0x0f,0x2b,0x0f,0x2a,0x0f,0x29,0x0f,0x28,0x0f,0x27,0x0f,0x26,0x0f,0x25,0x0f,0x24,0x0f,0x23,0x0f,0x22,0x0f,0x21,0x0f,0x20,0x0f,0x1f,0x0f,0x1e,0x0f,0x1d,0x0f,0x1c,0x0f,0x1b,0x0f,0x1a,0x0f,0x19,0x0f,0x18,0x0f,0x17,0x0f,0x16,0x0f,0x15,0x0f,0x14,0x0f,0x13,0x0f,0x12,0x0f,0x11,0x0f,0x10,0x0f,
//        0x0f,0x0f,0x0e,0x0f,0x0d,0x0f,0x0c,0x0f,0x0b,0x0f,0x0a,0x0f,0x09,0x0f,0x08,0x0f,0x07,0x0f,0x06,0x0f,0x05,0x0f,0x04,0x0f,0x03,0x0f,0x02,0x0f,0x01,0x0f,0x00,0x0f,0xff,0x0e,0xfe,0x0e,0xfd,0x0e,0xfc,0x0e,0xfb,0x0e,0xfa,0x0e,0xf9,0x0e,0xf8,0x0e,0xf7,0x0e,0xf6,0x0e,0xf5,0x0e,0xf4,0x0e,0xf3,0x0e,0xf2,0x0e,0xf1,0x0e,0xf0,0x0e,0xef,0x0e,0xee,0x0e,0xed,0x0e,0xec,0x0e,0xeb,0x0e,0xea,0x0e,0xe9,0x0e,0xe8,0x0e,0xe7,0x0e,0xe6,0x0e,0xe5,0x0e,0xe4,0x0e,0xe3,0x0e,0xe2,0x0e,0xe1,0x0e,0xe0,0x0e,0xdf,0x0e,0xde,0x0e,0xdd,0x0e,0xdc,0x0e,0xdb,0x0e,0xda,0x0e,0xd9,0x0e,0xd8,0x0e,0xd7,0x0e,0xd6,0x0e,0xd5,0x0e,0xd4,0x0e,0xd3,0x0e,0xd2,0x0e,0xd1,0x0e,0xd0,0x0e,0xcf,0x0e,0xce,0x0e,0xcd,0x0e,0xcc,0x0e,0xcb,0x0e,0xca,0x0e,0xc9,0x0e,0xc8,0x0e,0xc7,0x0e,0xc6,0x0e,0xc5,0x0e,0xc4,0x0e,0xc3,0x0e,0xc2,0x0e,0xc1,0x0e,0xc0,0x0e,0xbf,0x0e,0xbe,0x0e,0xbd,0x0e,0xbc,0x0e,0xbb,0x0e,0xba,0x0e,0xb9,0x0e,0xb8,0x0e,0xb7,0x0e,0xb6,0x0e,0xb5,0x0e,0xb4,0x0e,0xb3,0x0e,0xb2,0x0e,0xb1,0x0e,0xb0,0x0e,0xaf,0x0e,0xae,0x0e,0xad,0x0e,0xac,0x0e,0xab,0x0e,0xaa,0x0e,0xa9,0x0e,0xa8,0x0e,0xa7,0x0e,0xa6,0x0e,0xa5,0x0e,0xa4,0x0e,0xa3,0x0e,0xa2,0x0e,0xa1,0x0e,0xa0,0x0e,0x9f,0x0e,0x9e,0x0e,0x9d,0x0e,0x9c,0x0e,0x9b,0x0e,0x9a,0x0e,0x99,0x0e,0x98,0x0e,0x97,0x0e,0x96,0x0e,0x95,0x0e,0x94,0x0e,0x93,0x0e,0x92,0x0e,0x91,0x0e,0x90,0x0e,0x8f,0x0e,0x8e,0x0e,0x8d,0x0e,0x8c,0x0e,0x8b,0x0e,0x8a,0x0e,0x89,0x0e,0x88,0x0e,0x87,0x0e,0x86,0x0e,0x85,0x0e,0x84,0x0e,0x83,0x0e,0x82,0x0e,0x81,0x0e,0x80,0x0e,0x7f,0x0e,0x7e,0x0e,0x7d,0x0e,0x7c,0x0e,0x7b,0x0e,0x7a,0x0e,0x79,0x0e,0x78,0x0e,0x77,0x0e,0x76,0x0e,0x75,0x0e,0x74,0x0e,0x73,0x0e,0x72,0x0e,0x71,0x0e,0x70,0x0e,0x6f,0x0e,0x6e,0x0e,0x6d,0x0e,0x6c,0x0e,0x6b,0x0e,0x6a,0x0e,0x69,0x0e,0x68,0x0e,0x67,0x0e,0x66,0x0e,0x65,0x0e,0x64,0x0e,0x63,0x0e,0x62,0x0e,0x61,0x0e,0x60,0x0e,0x5f,0x0e,0x5e,0x0e,0x5d,0x0e,0x5c,0x0e,0x5b,0x0e,0x5a,0x0e,0x59,0x0e,0x58,0x0e,0x57,0x0e,0x56,0x0e,0x55,0x0e,0x54,0x0e,0x53,0x0e,0x52,0x0e,0x51,0x0e,0x50,0x0e,0x4f,0x0e,0x4e,0x0e,0x4d,0x0e,0x4c,0x0e,0x4b,0x0e,0x4a,0x0e,0x49,0x0e,0x48,0x0e,0x47,0x0e,0x46,0x0e,0x45,0x0e,0x44,0x0e,0x43,0x0e,0x42,0x0e,0x41,0x0e,0x40,0x0e,0x3f,0x0e,0x3e,0x0e,0x3d,0x0e,0x3c,0x0e,0x3b,0x0e,0x3a,0x0e,0x39,0x0e,0x38,0x0e,0x37,0x0e,0x36,0x0e,0x35,0x0e,0x34,0x0e,0x33,0x0e,0x32,0x0e,0x31,0x0e,0x30,0x0e,0x2f,0x0e,0x2e,0x0e,0x2d,0x0e,0x2c,0x0e,0x2b,0x0e,0x2a,0x0e,0x29,0x0e,0x28,0x0e,0x27,0x0e,0x26,0x0e,0x25,0x0e,0x24,0x0e,0x23,0x0e,0x22,0x0e,0x21,0x0e,0x20,0x0e,0x1f,0x0e,0x1e,0x0e,0x1d,0x0e,0x1c,0x0e,0x1b,0x0e,0x1a,0x0e,0x19,0x0e,0x18,0x0e,0x17,0x0e,0x16,0x0e,0x15,0x0e,0x14,0x0e,0x13,0x0e,0x12,0x0e,0x11,0x0e,0x10,0x0e,
//        0x0f,0x0e,0x0e,0x0e,0x0d,0x0e,0x0c,0x0e,0x0b,0x0e,0x0a,0x0e,0x09,0x0e,0x08,0x0e,0x07,0x0e,0x06,0x0e,0x05,0x0e,0x04,0x0e,0x03,0x0e,0x02,0x0e,0x01,0x0e,0x00,0x0e,0xff,0x0d,0xfe,0x0d,0xfd,0x0d,0xfc,0x0d,0xfb,0x0d,0xfa,0x0d,0xf9,0x0d,0xf8,0x0d,0xf7,0x0d,0xf6,0x0d,0xf5,0x0d,0xf4,0x0d,0xf3,0x0d,0xf2,0x0d,0xf1,0x0d,0xf0,0x0d,0xef,0x0d,0xee,0x0d,0xed,0x0d,0xec,0x0d,0xeb,0x0d,0xea,0x0d,0xe9,0x0d,0xe8,0x0d,0xe7,0x0d,0xe6,0x0d,0xe5,0x0d,0xe4,0x0d,0xe3,0x0d,0xe2,0x0d,0xe1,0x0d,0xe0,0x0d,0xdf,0x0d,0xde,0x0d,0xdd,0x0d,0xdc,0x0d,0xdb,0x0d,0xda,0x0d,0xd9,0x0d,0xd8,0x0d,0xd7,0x0d,0xd6,0x0d,0xd5,0x0d,0xd4,0x0d,0xd3,0x0d,0xd2,0x0d,0xd1,0x0d,0xd0,0x0d,0xcf,0x0d,0xce,0x0d,0xcd,0x0d,0xcc,0x0d,0xcb,0x0d,0xca,0x0d,0xc9,0x0d,0xc8,0x0d,0xc7,0x0d,0xc6,0x0d,0xc5,0x0d,0xc4,0x0d,0xc3,0x0d,0xc2,0x0d,0xc1,0x0d,0xc0,0x0d,0xbf,0x0d,0xbe,0x0d,0xbd,0x0d,0xbc,0x0d,0xbb,0x0d,0xba,0x0d,0xb9,0x0d,0xb8,0x0d,0xb7,0x0d,0xb6,0x0d,0xb5,0x0d,0xb4,0x0d,0xb3,0x0d,0xb2,0x0d,0xb1,0x0d,0xb0,0x0d,0xaf,0x0d,0xae,0x0d,0xad,0x0d,0xac,0x0d,0xab,0x0d,0xaa,0x0d,0xa9,0x0d,0xa8,0x0d,0xa7,0x0d,0xa6,0x0d,0xa5,0x0d,0xa4,0x0d,0xa3,0x0d,0xa2,0x0d,0xa1,0x0d,0xa0,0x0d,0x9f,0x0d,0x9e,0x0d,0x9d,0x0d,0x9c,0x0d,0x9b,0x0d,0x9a,0x0d,0x99,0x0d,0x98,0x0d,0x97,0x0d,0x96,0x0d,0x95,0x0d,0x94,0x0d,0x93,0x0d,0x92,0x0d,0x91,0x0d,0x90,0x0d,0x8f,0x0d,0x8e,0x0d,0x8d,0x0d,0x8c,0x0d,0x8b,0x0d,0x8a,0x0d,0x89,0x0d,0x88,0x0d,0x87,0x0d,0x86,0x0d,0x85,0x0d,0x84,0x0d,0x83,0x0d,0x82,0x0d,0x81,0x0d,0x80,0x0d,0x7f,0x0d,0x7e,0x0d,0x7d,0x0d,0x7c,0x0d,0x7b,0x0d,0x7a,0x0d,0x79,0x0d,0x78,0x0d,0x77,0x0d,0x76,0x0d,0x75,0x0d,0x74,0x0d,0x73,0x0d,0x72,0x0d,0x71,0x0d,0x70,0x0d,0x6f,0x0d,0x6e,0x0d,0x6d,0x0d,0x6c,0x0d,0x6b,0x0d,0x6a,0x0d,0x69,0x0d,0x68,0x0d,0x67,0x0d,0x66,0x0d,0x65,0x0d,0x64,0x0d,0x63,0x0d,0x62,0x0d,0x61,0x0d,0x60,0x0d,0x5f,0x0d,0x5e,0x0d,0x5d,0x0d,0x5c,0x0d,0x5b,0x0d,0x5a,0x0d,0x59,0x0d,0x58,0x0d,0x57,0x0d,0x56,0x0d,0x55,0x0d,0x54,0x0d,0x53,0x0d,0x52,0x0d,0x51,0x0d,0x50,0x0d,0x4f,0x0d,0x4e,0x0d,0x4d,0x0d,0x4c,0x0d,0x4b,0x0d,0x4a,0x0d,0x49,0x0d,0x48,0x0d,0x47,0x0d,0x46,0x0d,0x45,0x0d,0x44,0x0d,0x43,0x0d,0x42,0x0d,0x41,0x0d,0x40,0x0d,0x3f,0x0d,0x3e,0x0d,0x3d,0x0d,0x3c,0x0d,0x3b,0x0d,0x3a,0x0d,0x39,0x0d,0x38,0x0d,0x37,0x0d,0x36,0x0d,0x35,0x0d,0x34,0x0d,0x33,0x0d,0x32,0x0d,0x31,0x0d,0x30,0x0d,0x2f,0x0d,0x2e,0x0d,0x2d,0x0d,0x2c,0x0d,0x2b,0x0d,0x2a,0x0d,0x29,0x0d,0x28,0x0d,0x27,0x0d,0x26,0x0d,0x25,0x0d,0x24,0x0d,0x23,0x0d,0x22,0x0d,0x21,0x0d,0x20,0x0d,0x1f,0x0d,0x1e,0x0d,0x1d,0x0d,0x1c,0x0d,0x1b,0x0d,0x1a,0x0d,0x19,0x0d,0x18,0x0d,0x17,0x0d,0x16,0x0d,0x15,0x0d,0x14,0x0d,0x13,0x0d,0x12,0x0d,0x11,0x0d,0x10,0x0d,
//        0x0f,0x0d,0x0e,0x0d,0x0d,0x0d,0x0c,0x0d,0x0b,0x0d,0x0a,0x0d,0x09,0x0d,0x08,0x0d,0x07,0x0d,0x06,0x0d,0x05,0x0d,0x04,0x0d,0x03,0x0d,0x02,0x0d,0x01,0x0d,0x00,0x0d,0xff,0x0c,0xfe,0x0c,0xfd,0x0c,0xfc,0x0c,0xfb,0x0c,0xfa,0x0c,0xf9,0x0c,0xf8,0x0c,0xf7,0x0c,0xf6,0x0c,0xf5,0x0c,0xf4,0x0c,0xf3,0x0c,0xf2,0x0c,0xf1,0x0c,0xf0,0x0c,0xef,0x0c,0xee,0x0c,0xed,0x0c,0xec,0x0c,0xeb,0x0c,0xea,0x0c,0xe9,0x0c,0xe8,0x0c,0xe7,0x0c,0xe6,0x0c,0xe5,0x0c,0xe4,0x0c,0xe3,0x0c,0xe2,0x0c,0xe1,0x0c,0xe0,0x0c,0xdf,0x0c,0xde,0x0c,0xdd,0x0c,0xdc,0x0c,0xdb,0x0c,0xda,0x0c,0xd9,0x0c,0xd8,0x0c,0xd7,0x0c,0xd6,0x0c,0xd5,0x0c,0xd4,0x0c,0xd3,0x0c,0xd2,0x0c,0xd1,0x0c,0xd0,0x0c,0xcf,0x0c,0xce,0x0c,0xcd,0x0c,0xcc,0x0c,0xcb,0x0c,0xca,0x0c,0xc9,0x0c,0xc8,0x0c,0xc7,0x0c,0xc6,0x0c,0xc5,0x0c,0xc4,0x0c,0xc3,0x0c,0xc2,0x0c,0xc1,0x0c,0xc0,0x0c,0xbf,0x0c,0xbe,0x0c,0xbd,0x0c,0xbc,0x0c,0xbb,0x0c,0xba,0x0c,0xb9,0x0c,0xb8,0x0c,0xb7,0x0c,0xb6,0x0c,0xb5,0x0c,0xb4,0x0c,0xb3,0x0c,0xb2,0x0c,0xb1,0x0c,0xb0,0x0c,0xaf,0x0c,0xae,0x0c,0xad,0x0c,0xac,0x0c,0xab,0x0c,0xaa,0x0c,0xa9,0x0c,0xa8,0x0c,0xa7,0x0c,0xa6,0x0c,0xa5,0x0c,0xa4,0x0c,0xa3,0x0c,0xa2,0x0c,0xa1,0x0c,0xa0,0x0c,0x9f,0x0c,0x9e,0x0c,0x9d,0x0c,0x9c,0x0c,0x9b,0x0c,0x9a,0x0c,0x99,0x0c,0x98,0x0c,0x97,0x0c,0x96,0x0c,0x95,0x0c,0x94,0x0c,0x93,0x0c,0x92,0x0c,0x91,0x0c,0x90,0x0c,0x8f,0x0c,0x8e,0x0c,0x8d,0x0c,0x8c,0x0c,0x8b,0x0c,0x8a,0x0c,0x89,0x0c,0x88,0x0c,0x87,0x0c,0x86,0x0c,0x85,0x0c,0x84,0x0c,0x83,0x0c,0x82,0x0c,0x81,0x0c,0x80,0x0c,0x7f,0x0c,0x7e,0x0c,0x7d,0x0c,0x7c,0x0c,0x7b,0x0c,0x7a,0x0c,0x79,0x0c,0x78,0x0c,0x77,0x0c,0x76,0x0c,0x75,0x0c,0x74,0x0c,0x73,0x0c,0x72,0x0c,0x71,0x0c,0x70,0x0c,0x6f,0x0c,0x6e,0x0c,0x6d,0x0c,0x6c,0x0c,0x6b,0x0c,0x6a,0x0c,0x69,0x0c,0x68,0x0c,0x67,0x0c,0x66,0x0c,0x65,0x0c,0x64,0x0c,0x63,0x0c,0x62,0x0c,0x61,0x0c,0x60,0x0c,0x5f,0x0c,0x5e,0x0c,0x5d,0x0c,0x5c,0x0c,0x5b,0x0c,0x5a,0x0c,0x59,0x0c,0x58,0x0c,0x57,0x0c,0x56,0x0c,0x55,0x0c,0x54,0x0c,0x53,0x0c,0x52,0x0c,0x51,0x0c,0x50,0x0c,0x4f,0x0c,0x4e,0x0c,0x4d,0x0c,0x4c,0x0c,0x4b,0x0c,0x4a,0x0c,0x49,0x0c,0x48,0x0c,0x47,0x0c,0x46,0x0c,0x45,0x0c,0x44,0x0c,0x43,0x0c,0x42,0x0c,0x41,0x0c,0x40,0x0c,0x3f,0x0c,0x3e,0x0c,0x3d,0x0c,0x3c,0x0c,0x3b,0x0c,0x3a,0x0c,0x39,0x0c,0x38,0x0c,0x37,0x0c,0x36,0x0c,0x35,0x0c,0x34,0x0c,0x33,0x0c,0x32,0x0c,0x31,0x0c,0x30,0x0c,0x2f,0x0c,0x2e,0x0c,0x2d,0x0c,0x2c,0x0c,0x2b,0x0c,0x2a,0x0c,0x29,0x0c,0x28,0x0c,0x27,0x0c,0x26,0x0c,0x25,0x0c,0x24,0x0c,0x23,0x0c,0x22,0x0c,0x21,0x0c,0x20,0x0c,0x1f,0x0c,0x1e,0x0c,0x1d,0x0c,0x1c,0x0c,0x1b,0x0c,0x1a,0x0c,0x19,0x0c,0x18,0x0c,0x17,0x0c,0x16,0x0c,0x15,0x0c,0x14,0x0c,0x13,0x0c,0x12,0x0c,0x11,0x0c,0x10,0x0c,
//        0x0f,0x0c,0x0e,0x0c,0x0d,0x0c,0x0c,0x0c,0x0b,0x0c,0x0a,0x0c,0x09,0x0c,0x08,0x0c,0x07,0x0c,0x06,0x0c,0x05,0x0c,0x04,0x0c,0x03,0x0c,0x02,0x0c,0x01,0x0c,0x00,0x0c,0xff,0x0b,0xfe,0x0b,0xfd,0x0b,0xfc,0x0b,0xfb,0x0b,0xfa,0x0b,0xf9,0x0b,0xf8,0x0b,0xf7,0x0b,0xf6,0x0b,0xf5,0x0b,0xf4,0x0b,0xf3,0x0b,0xf2,0x0b,0xf1,0x0b,0xf0,0x0b,0xef,0x0b,0xee,0x0b,0xed,0x0b,0xec,0x0b,0xeb,0x0b,0xea,0x0b,0xe9,0x0b,0xe8,0x0b,0xe7,0x0b,0xe6,0x0b,0xe5,0x0b,0xe4,0x0b,0xe3,0x0b,0xe2,0x0b,0xe1,0x0b,0xe0,0x0b,0xdf,0x0b,0xde,0x0b,0xdd,0x0b,0xdc,0x0b,0xdb,0x0b,0xda,0x0b,0xd9,0x0b,0xd8,0x0b,0xd7,0x0b,0xd6,0x0b,0xd5,0x0b,0xd4,0x0b,0xd3,0x0b,0xd2,0x0b,0xd1,0x0b,0xd0,0x0b,0xcf,0x0b,0xce,0x0b,0xcd,0x0b,0xcc,0x0b,0xcb,0x0b,0xca,0x0b,0xc9,0x0b,0xc8,0x0b,0xc7,0x0b,0xc6,0x0b,0xc5,0x0b,0xc4,0x0b,0xc3,0x0b,0xc2,0x0b,0xc1,0x0b,0xc0,0x0b,0xbf,0x0b,0xbe,0x0b,0xbd,0x0b,0xbc,0x0b,0xbb,0x0b,0xba,0x0b,0xb9,0x0b,0xb8,0x0b,0xb7,0x0b,0xb6,0x0b,0xb5,0x0b,0xb4,0x0b,0xb3,0x0b,0xb2,0x0b,0xb1,0x0b,0xb0,0x0b,0xaf,0x0b,0xae,0x0b,0xad,0x0b,0xac,0x0b,0xab,0x0b,0xaa,0x0b,0xa9,0x0b,0xa8,0x0b,0xa7,0x0b,0xa6,0x0b,0xa5,0x0b,0xa4,0x0b,0xa3,0x0b,0xa2,0x0b,0xa1,0x0b,0xa0,0x0b,0x9f,0x0b,0x9e,0x0b,0x9d,0x0b,0x9c,0x0b,0x9b,0x0b,0x9a,0x0b,0x99,0x0b,0x98,0x0b,0x97,0x0b,0x96,0x0b,0x95,0x0b,0x94,0x0b,0x93,0x0b,0x92,0x0b,0x91,0x0b,0x90,0x0b,0x8f,0x0b,0x8e,0x0b,0x8d,0x0b,0x8c,0x0b,0x8b,0x0b,0x8a,0x0b,0x89,0x0b,0x88,0x0b,0x87,0x0b,0x86,0x0b,0x85,0x0b,0x84,0x0b,0x83,0x0b,0x82,0x0b,0x81,0x0b,0x80,0x0b,0x7f,0x0b,0x7e,0x0b,0x7d,0x0b,0x7c,0x0b,0x7b,0x0b,0x7a,0x0b,0x79,0x0b,0x78,0x0b,0x77,0x0b,0x76,0x0b,0x75,0x0b,0x74,0x0b,0x73,0x0b,0x72,0x0b,0x71,0x0b,0x70,0x0b,0x6f,0x0b,0x6e,0x0b,0x6d,0x0b,0x6c,0x0b,0x6b,0x0b,0x6a,0x0b,0x69,0x0b,0x68,0x0b,0x67,0x0b,0x66,0x0b,0x65,0x0b,0x64,0x0b,0x63,0x0b,0x62,0x0b,0x61,0x0b,0x60,0x0b,0x5f,0x0b,0x5e,0x0b,0x5d,0x0b,0x5c,0x0b,0x5b,0x0b,0x5a,0x0b,0x59,0x0b,0x58,0x0b,0x57,0x0b,0x56,0x0b,0x55,0x0b,0x54,0x0b,0x53,0x0b,0x52,0x0b,0x51,0x0b,0x50,0x0b,0x4f,0x0b,0x4e,0x0b,0x4d,0x0b,0x4c,0x0b,0x4b,0x0b,0x4a,0x0b,0x49,0x0b,0x48,0x0b,0x47,0x0b,0x46,0x0b,0x45,0x0b,0x44,0x0b,0x43,0x0b,0x42,0x0b,0x41,0x0b,0x40,0x0b,0x3f,0x0b,0x3e,0x0b,0x3d,0x0b,0x3c,0x0b,0x3b,0x0b,0x3a,0x0b,0x39,0x0b,0x38,0x0b,0x37,0x0b,0x36,0x0b,0x35,0x0b,0x34,0x0b,0x33,0x0b,0x32,0x0b,0x31,0x0b,0x30,0x0b,0x2f,0x0b,0x2e,0x0b,0x2d,0x0b,0x2c,0x0b,0x2b,0x0b,0x2a,0x0b,0x29,0x0b,0x28,0x0b,0x27,0x0b,0x26,0x0b,0x25,0x0b,0x24,0x0b,0x23,0x0b,0x22,0x0b,0x21,0x0b,0x20,0x0b,0x1f,0x0b,0x1e,0x0b,0x1d,0x0b,0x1c,0x0b,0x1b,0x0b,0x1a,0x0b,0x19,0x0b,0x18,0x0b,0x17,0x0b,0x16,0x0b,0x15,0x0b,0x14,0x0b,0x13,0x0b,0x12,0x0b,0x11,0x0b,0x10,0x0b,
//        0x0f,0x0b,0x0e,0x0b,0x0d,0x0b,0x0c,0x0b,0x0b,0x0b,0x0a,0x0b,0x09,0x0b,0x08,0x0b,0x07,0x0b,0x06,0x0b,0x05,0x0b,0x04,0x0b,0x03,0x0b,0x02,0x0b,0x01,0x0b,0x00,0x0b,0xff,0x0a,0xfe,0x0a,0xfd,0x0a,0xfc,0x0a,0xfb,0x0a,0xfa,0x0a,0xf9,0x0a,0xf8,0x0a,0xf7,0x0a,0xf6,0x0a,0xf5,0x0a,0xf4,0x0a,0xf3,0x0a,0xf2,0x0a,0xf1,0x0a,0xf0,0x0a,0xef,0x0a,0xee,0x0a,0xed,0x0a,0xec,0x0a,0xeb,0x0a,0xea,0x0a,0xe9,0x0a,0xe8,0x0a,0xe7,0x0a,0xe6,0x0a,0xe5,0x0a,0xe4,0x0a,0xe3,0x0a,0xe2,0x0a,0xe1,0x0a,0xe0,0x0a,0xdf,0x0a,0xde,0x0a,0xdd,0x0a,0xdc,0x0a,0xdb,0x0a,0xda,0x0a,0xd9,0x0a,0xd8,0x0a,0xd7,0x0a,0xd6,0x0a,0xd5,0x0a,0xd4,0x0a,0xd3,0x0a,0xd2,0x0a,0xd1,0x0a,0xd0,0x0a,0xcf,0x0a,0xce,0x0a,0xcd,0x0a,0xcc,0x0a,0xcb,0x0a,0xca,0x0a,0xc9,0x0a,0xc8,0x0a,0xc7,0x0a,0xc6,0x0a,0xc5,0x0a,0xc4,0x0a,0xc3,0x0a,0xc2,0x0a,0xc1,0x0a,0xc0,0x0a,0xbf,0x0a,0xbe,0x0a,0xbd,0x0a,0xbc,0x0a,0xbb,0x0a,0xba,0x0a,0xb9,0x0a,0xb8,0x0a,0xb7,0x0a,0xb6,0x0a,0xb5,0x0a,0xb4,0x0a,0xb3,0x0a,0xb2,0x0a,0xb1,0x0a,0xb0,0x0a,0xaf,0x0a,0xae,0x0a,0xad,0x0a,0xac,0x0a,0xab,0x0a,0xaa,0x0a,0xa9,0x0a,0xa8,0x0a,0xa7,0x0a,0xa6,0x0a,0xa5,0x0a,0xa4,0x0a,0xa3,0x0a,0xa2,0x0a,0xa1,0x0a,0xa0,0x0a,0x9f,0x0a,0x9e,0x0a,0x9d,0x0a,0x9c,0x0a,0x9b,0x0a,0x9a,0x0a,0x99,0x0a,0x98,0x0a,0x97,0x0a,0x96,0x0a,0x95,0x0a,0x94,0x0a,0x93,0x0a,0x92,0x0a,0x91,0x0a,0x90,0x0a,0x8f,0x0a,0x8e,0x0a,0x8d,0x0a,0x8c,0x0a,0x8b,0x0a,0x8a,0x0a,0x89,0x0a,0x88,0x0a,0x87,0x0a,0x86,0x0a,0x85,0x0a,0x84,0x0a,0x83,0x0a,0x82,0x0a,0x81,0x0a,0x80,0x0a,0x7f,0x0a,0x7e,0x0a,0x7d,0x0a,0x7c,0x0a,0x7b,0x0a,0x7a,0x0a,0x79,0x0a,0x78,0x0a,0x77,0x0a,0x76,0x0a,0x75,0x0a,0x74,0x0a,0x73,0x0a,0x72,0x0a,0x71,0x0a,0x70,0x0a,0x6f,0x0a,0x6e,0x0a,0x6d,0x0a,0x6c,0x0a,0x6b,0x0a,0x6a,0x0a,0x69,0x0a,0x68,0x0a,0x67,0x0a,0x66,0x0a,0x65,0x0a,0x64,0x0a,0x63,0x0a,0x62,0x0a,0x61,0x0a,0x60,0x0a,0x5f,0x0a,0x5e,0x0a,0x5d,0x0a,0x5c,0x0a,0x5b,0x0a,0x5a,0x0a,0x59,0x0a,0x58,0x0a,0x57,0x0a,0x56,0x0a,0x55,0x0a,0x54,0x0a,0x53,0x0a,0x52,0x0a,0x51,0x0a,0x50,0x0a,0x4f,0x0a,0x4e,0x0a,0x4d,0x0a,0x4c,0x0a,0x4b,0x0a,0x4a,0x0a,0x49,0x0a,0x48,0x0a,0x47,0x0a,0x46,0x0a,0x45,0x0a,0x44,0x0a,0x43,0x0a,0x42,0x0a,0x41,0x0a,0x40,0x0a,0x3f,0x0a,0x3e,0x0a,0x3d,0x0a,0x3c,0x0a,0x3b,0x0a,0x3a,0x0a,0x39,0x0a,0x38,0x0a,0x37,0x0a,0x36,0x0a,0x35,0x0a,0x34,0x0a,0x33,0x0a,0x32,0x0a,0x31,0x0a,0x30,0x0a,0x2f,0x0a,0x2e,0x0a,0x2d,0x0a,0x2c,0x0a,0x2b,0x0a,0x2a,0x0a,0x29,0x0a,0x28,0x0a,0x27,0x0a,0x26,0x0a,0x25,0x0a,0x24,0x0a,0x23,0x0a,0x22,0x0a,0x21,0x0a,0x20,0x0a,0x1f,0x0a,0x1e,0x0a,0x1d,0x0a,0x1c,0x0a,0x1b,0x0a,0x1a,0x0a,0x19,0x0a,0x18,0x0a,0x17,0x0a,0x16,0x0a,0x15,0x0a,0x14,0x0a,0x13,0x0a,0x12,0x0a,0x11,0x0a,0x10,0x0a,
//        0x0f,0x0a,0x0e,0x0a,0x0d,0x0a,0x0c,0x0a,0x0b,0x0a,0x0a,0x0a,0x09,0x0a,0x08,0x0a,0x07,0x0a,0x06,0x0a,0x05,0x0a,0x04,0x0a,0x03,0x0a,0x02,0x0a,0x01,0x0a,0x00,0x0a,0xff,0x09,0xfe,0x09,0xfd,0x09,0xfc,0x09,0xfb,0x09,0xfa,0x09,0xf9,0x09,0xf8,0x09,0xf7,0x09,0xf6,0x09,0xf5,0x09,0xf4,0x09,0xf3,0x09,0xf2,0x09,0xf1,0x09,0xf0,0x09,0xef,0x09,0xee,0x09,0xed,0x09,0xec,0x09,0xeb,0x09,0xea,0x09,0xe9,0x09,0xe8,0x09,0xe7,0x09,0xe6,0x09,0xe5,0x09,0xe4,0x09,0xe3,0x09,0xe2,0x09,0xe1,0x09,0xe0,0x09,0xdf,0x09,0xde,0x09,0xdd,0x09,0xdc,0x09,0xdb,0x09,0xda,0x09,0xd9,0x09,0xd8,0x09,0xd7,0x09,0xd6,0x09,0xd5,0x09,0xd4,0x09,0xd3,0x09,0xd2,0x09,0xd1,0x09,0xd0,0x09,0xcf,0x09,0xce,0x09,0xcd,0x09,0xcc,0x09,0xcb,0x09,0xca,0x09,0xc9,0x09,0xc8,0x09,0xc7,0x09,0xc6,0x09,0xc5,0x09,0xc4,0x09,0xc3,0x09,0xc2,0x09,0xc1,0x09,0xc0,0x09,0xbf,0x09,0xbe,0x09,0xbd,0x09,0xbc,0x09,0xbb,0x09,0xba,0x09,0xb9,0x09,0xb8,0x09,0xb7,0x09,0xb6,0x09,0xb5,0x09,0xb4,0x09,0xb3,0x09,0xb2,0x09,0xb1,0x09,0xb0,0x09,0xaf,0x09,0xae,0x09,0xad,0x09,0xac,0x09,0xab,0x09,0xaa,0x09,0xa9,0x09,0xa8,0x09,0xa7,0x09,0xa6,0x09,0xa5,0x09,0xa4,0x09,0xa3,0x09,0xa2,0x09,0xa1,0x09,0xa0,0x09,0x9f,0x09,0x9e,0x09,0x9d,0x09,0x9c,0x09,0x9b,0x09,0x9a,0x09,0x99,0x09,0x98,0x09,0x97,0x09,0x96,0x09,0x95,0x09,0x94,0x09,0x93,0x09,0x92,0x09,0x91,0x09,0x90,0x09,0x8f,0x09,0x8e,0x09,0x8d,0x09,0x8c,0x09,0x8b,0x09,0x8a,0x09,0x89,0x09,0x88,0x09,0x87,0x09,0x86,0x09,0x85,0x09,0x84,0x09,0x83,0x09,0x82,0x09,0x81,0x09,0x80,0x09,0x7f,0x09,0x7e,0x09,0x7d,0x09,0x7c,0x09,0x7b,0x09,0x7a,0x09,0x79,0x09,0x78,0x09,0x77,0x09,0x76,0x09,0x75,0x09,0x74,0x09,0x73,0x09,0x72,0x09,0x71,0x09,0x70,0x09,0x6f,0x09,0x6e,0x09,0x6d,0x09,0x6c,0x09,0x6b,0x09,0x6a,0x09,0x69,0x09,0x68,0x09,0x67,0x09,0x66,0x09,0x65,0x09,0x64,0x09,0x63,0x09,0x62,0x09,0x61,0x09,0x60,0x09,0x5f,0x09,0x5e,0x09,0x5d,0x09,0x5c,0x09,0x5b,0x09,0x5a,0x09,0x59,0x09,0x58,0x09,0x57,0x09,0x56,0x09,0x55,0x09,0x54,0x09,0x53,0x09,0x52,0x09,0x51,0x09,0x50,0x09,0x4f,0x09,0x4e,0x09,0x4d,0x09,0x4c,0x09,0x4b,0x09,0x4a,0x09,0x49,0x09,0x48,0x09,0x47,0x09,0x46,0x09,0x45,0x09,0x44,0x09,0x43,0x09,0x42,0x09,0x41,0x09,0x40,0x09,0x3f,0x09,0x3e,0x09,0x3d,0x09,0x3c,0x09,0x3b,0x09,0x3a,0x09,0x39,0x09,0x38,0x09,0x37,0x09,0x36,0x09,0x35,0x09,0x34,0x09,0x33,0x09,0x32,0x09,0x31,0x09,0x30,0x09,0x2f,0x09,0x2e,0x09,0x2d,0x09,0x2c,0x09,0x2b,0x09,0x2a,0x09,0x29,0x09,0x28,0x09,0x27,0x09,0x26,0x09,0x25,0x09,0x24,0x09,0x23,0x09,0x22,0x09,0x21,0x09,0x20,0x09,0x1f,0x09,0x1e,0x09,0x1d,0x09,0x1c,0x09,0x1b,0x09,0x1a,0x09,0x19,0x09,0x18,0x09,0x17,0x09,0x16,0x09,0x15,0x09,0x14,0x09,0x13,0x09,0x12,0x09,0x11,0x09,0x10,0x09,
//        0x0f,0x09,0x0e,0x09,0x0d,0x09,0x0c,0x09,0x0b,0x09,0x0a,0x09,0x09,0x09,0x08,0x09,0x07,0x09,0x06,0x09,0x05,0x09,0x04,0x09,0x03,0x09,0x02,0x09,0x01,0x09,0x00,0x09,0xff,0x08,0xfe,0x08,0xfd,0x08,0xfc,0x08,0xfb,0x08,0xfa,0x08,0xf9,0x08,0xf8,0x08,0xf7,0x08,0xf6,0x08,0xf5,0x08,0xf4,0x08,0xf3,0x08,0xf2,0x08,0xf1,0x08,0xf0,0x08,0xef,0x08,0xee,0x08,0xed,0x08,0xec,0x08,0xeb,0x08,0xea,0x08,0xe9,0x08,0xe8,0x08,0xe7,0x08,0xe6,0x08,0xe5,0x08,0xe4,0x08,0xe3,0x08,0xe2,0x08,0xe1,0x08,0xe0,0x08,0xdf,0x08,0xde,0x08,0xdd,0x08,0xdc,0x08,0xdb,0x08,0xda,0x08,0xd9,0x08,0xd8,0x08,0xd7,0x08,0xd6,0x08,0xd5,0x08,0xd4,0x08,0xd3,0x08,0xd2,0x08,0xd1,0x08,0xd0,0x08,0xcf,0x08,0xce,0x08,0xcd,0x08,0xcc,0x08,0xcb,0x08,0xca,0x08,0xc9,0x08,0xc8,0x08,0xc7,0x08,0xc6,0x08,0xc5,0x08,0xc4,0x08,0xc3,0x08,0xc2,0x08,0xc1,0x08,0xc0,0x08,0xbf,0x08,0xbe,0x08,0xbd,0x08,0xbc,0x08,0xbb,0x08,0xba,0x08,0xb9,0x08,0xb8,0x08,0xb7,0x08,0xb6,0x08,0xb5,0x08,0xb4,0x08,0xb3,0x08,0xb2,0x08,0xb1,0x08,0xb0,0x08,0xaf,0x08,0xae,0x08,0xad,0x08,0xac,0x08,0xab,0x08,0xaa,0x08,0xa9,0x08,0xa8,0x08,0xa7,0x08,0xa6,0x08,0xa5,0x08,0xa4,0x08,0xa3,0x08,0xa2,0x08,0xa1,0x08,0xa0,0x08,0x9f,0x08,0x9e,0x08,0x9d,0x08,0x9c,0x08,0x9b,0x08,0x9a,0x08,0x99,0x08,0x98,0x08,0x97,0x08,0x96,0x08,0x95,0x08,0x94,0x08,0x93,0x08,0x92,0x08,0x91,0x08,0x90,0x08,0x8f,0x08,0x8e,0x08,0x8d,0x08,0x8c,0x08,0x8b,0x08,0x8a,0x08,0x89,0x08,0x88,0x08,0x87,0x08,0x86,0x08,0x85,0x08,0x84,0x08,0x83,0x08,0x82,0x08,0x81,0x08,0x80,0x08,0x7f,0x08,0x7e,0x08,0x7d,0x08,0x7c,0x08,0x7b,0x08,0x7a,0x08,0x79,0x08,0x78,0x08,0x77,0x08,0x76,0x08,0x75,0x08,0x74,0x08,0x73,0x08,0x72,0x08,0x71,0x08,0x70,0x08,0x6f,0x08,0x6e,0x08,0x6d,0x08,0x6c,0x08,0x6b,0x08,0x6a,0x08,0x69,0x08,0x68,0x08,0x67,0x08,0x66,0x08,0x65,0x08,0x64,0x08,0x63,0x08,0x62,0x08,0x61,0x08,0x60,0x08,0x5f,0x08,0x5e,0x08,0x5d,0x08,0x5c,0x08,0x5b,0x08,0x5a,0x08,0x59,0x08,0x58,0x08,0x57,0x08,0x56,0x08,0x55,0x08,0x54,0x08,0x53,0x08,0x52,0x08,0x51,0x08,0x50,0x08,0x4f,0x08,0x4e,0x08,0x4d,0x08,0x4c,0x08,0x4b,0x08,0x4a,0x08,0x49,0x08,0x48,0x08,0x47,0x08,0x46,0x08,0x45,0x08,0x44,0x08,0x43,0x08,0x42,0x08,0x41,0x08,0x40,0x08,0x3f,0x08,0x3e,0x08,0x3d,0x08,0x3c,0x08,0x3b,0x08,0x3a,0x08,0x39,0x08,0x38,0x08,0x37,0x08,0x36,0x08,0x35,0x08,0x34,0x08,0x33,0x08,0x32,0x08,0x31,0x08,0x30,0x08,0x2f,0x08,0x2e,0x08,0x2d,0x08,0x2c,0x08,0x2b,0x08,0x2a,0x08,0x29,0x08,0x28,0x08,0x27,0x08,0x26,0x08,0x25,0x08,0x24,0x08,0x23,0x08,0x22,0x08,0x21,0x08,0x20,0x08,0x1f,0x08,0x1e,0x08,0x1d,0x08,0x1c,0x08,0x1b,0x08,0x1a,0x08,0x19,0x08,0x18,0x08,0x17,0x08,0x16,0x08,0x15,0x08,0x14,0x08,0x13,0x08,0x12,0x08,0x11,0x08,0x10,0x08,
//        0x0f,0x08,0x0e,0x08,0x0d,0x08,0x0c,0x08,0x0b,0x08,0x0a,0x08,0x09,0x08,0x08,0x08,0x07,0x08,0x06,0x08,0x05,0x08,0x04,0x08,0x03,0x08,0x02,0x08,0x01,0x08,0x00,0x08,0x40,0xa3,0xd5,0x7c,
//    };
//    const uint32_t checksumExpected = ChecksumFletcher32(data, sizeof(data)-4);
//    uint32_t checksumGot = 0;
//    memcpy(&checksumGot, data+sizeof(data)-4, sizeof(checksumGot));
//    printf("checksumExpected:0x%08x checksumGot:0x%08x\n", checksumExpected, checksumGot);
//    return 0;
    
//    const uint8_t chars[] = {'a', 'b', 'c', 'd', 'e', 0};             // 0xf04fc729
////    const uint8_t chars[] = {'a', 'b', 'c', 'd', 'e', 'f'};           // 0x56502d2a
////    const uint8_t chars[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}; // 0xebe19591
//    const uint32_t checksum = ChecksumFletcher32(chars, sizeof(chars));
//    printf("checksum: 0x%08x\n", checksum);
//    return 0;
    
    Args args;
    try {
        args = parseArgs(argc-1, argv+1);
    
    } catch (const std::exception& e) {
        fprintf(stderr, "Bad arguments: %s\n\n", e.what());
        printUsage();
        return 1;
    }
    
    std::vector<MDCUSBDevicePtr> devices;
    try {
        devices = MDCUSBDevice::GetDevices();
    } catch (const std::exception& e) {
        fprintf(stderr, "Failed to get MDC loader devices: %s\n\n", e.what());
        return 1;
    }
    
    if (devices.empty()) {
        fprintf(stderr, "No matching MDC devices\n\n");
        return 1;
    } else if (devices.size() > 1) {
        fprintf(stderr, "Too many matching MDC devices\n\n");
        return 1;
    }
    
    MDCUSBDevice& device = *(devices[0]);
    try {
        if (args.cmd == lower(ResetCmd))                    Reset(args, device);
        else if (args.cmd == lower(StatusGetCmd))           StatusGet(args, device);
        else if (args.cmd == lower(BatteryStatusGetCmd))    BatteryStatusGet(args, device);
        else if (args.cmd == lower(BootloaderInvokeCmd))    BootloaderInvoke(args, device);
        else if (args.cmd == lower(LEDSetCmd))              LEDSet(args, device);
        else if (args.cmd == lower(STMRAMWriteCmd))         STMRAMWrite(args, device);
        else if (args.cmd == lower(STMRAMWriteLegacyCmd))   STMRAMWriteLegacy(args, device);
        else if (args.cmd == lower(STMFlashWriteCmd))       STMFlashWrite(args, device);
        else if (args.cmd == lower(HostModeSetCmd))         HostModeSet(args, device);
        else if (args.cmd == lower(ICERAMWriteCmd))         ICERAMWrite(args, device);
        else if (args.cmd == lower(ICEFlashReadCmd))        ICEFlashRead(args, device);
        else if (args.cmd == lower(ICEFlashWriteCmd))       ICEFlashWrite(args, device);
        else if (args.cmd == lower(MSPStateReadCmd))        MSPStateRead(args, device);
        else if (args.cmd == lower(MSPStateWriteCmd))       MSPStateWrite(args, device);
        else if (args.cmd == lower(MSPTimeGetCmd))          MSPTimeGet(args, device);
        else if (args.cmd == lower(MSPTimeInitCmd))         MSPTimeInit(args, device);
        else if (args.cmd == lower(MSPTimeAdjustCmd))       MSPTimeAdjust(args, device);
        else if (args.cmd == lower(MSPSBWReadCmd))          MSPSBWRead(args, device);
        else if (args.cmd == lower(MSPSBWWriteCmd))         MSPSBWWrite(args, device);
        else if (args.cmd == lower(MSPSBWEraseCmd))         MSPSBWErase(args, device);
        else if (args.cmd == lower(MSPSBWDebugLogCmd))      MSPSBWDebugLog(args, device);
        else if (args.cmd == lower(SDReadCmd))              SDRead(args, device);
        else if (args.cmd == lower(SDEraseCmd))             SDErase(args, device);
        else if (args.cmd == lower(ImgReadFullCmd))         ImgReadFull(args, device);
        else if (args.cmd == lower(ImgReadThumbCmd))        ImgReadThumb(args, device);
        else if (args.cmd == lower(ImgCaptureCmd))          ImgCapture(args, device);
    
    } catch (const std::exception& e) {
        fprintf(stderr, "Error: %s\n", e.what());
        return 1;
    }
    
    return 0;
}
