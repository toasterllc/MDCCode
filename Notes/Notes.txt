- Rev4 todo

    - STM32: Fix USB power supply
        - VDD_USB (ball H13) should be supplied with 3-3.6V, but for some reason we tied it to 1V8 on the Rev3 board
    
    - ICE40: Fix pin layout so that both PLLs can be used
        - Fix B6 PLL: swap A6 and B6 (RAM_DQM0 is output-only)
        - Fix L5 PLL: ?
        - When a PLL is used, the tile that it's on can only be used as an output pin (not an input pin). So make PLL IO tiles either outputs, or unused
        - "PLL input path is shared with the IO input path of the IO tile it's in":
            https://freenode.irclog.whitequark.org/yosys/2019-03-13
            https://logs.timvideos.us/%23yosys/%23yosys.2019-03-13.log.html
    
    - Consider lowering 2V8 rail to 2V7-ish, so that it's easier to meet the SD card Vih in 3.3V mode
        - Vih(2.8V) = 0.625*VDD = .625*2.8 = 1.75 V => only 50mV away from 1.8V rail
        - Vih(2.7V) = 0.625*VDD = .625*2.7 = 1.6875 V => 0.1125 => 113mV away from 1.8V rail
    
    - Add motion detector
    
    - Add MSP430 (MSP430FR2422)
        - Needs FRAM to store the bitmap of the SD card usage
        - Needs connection to ICE40, to issue commands
            - Options:
                - 2-wire SPI (clk, data): connect MSP430 MOSI/MISO together, and ensure:
                    - During Tx: MOSI=Driven
                    - During Rx: MOSI=HighZ
                    - 2021-4-28: confirmed that this technique should work by using the CurrentSensor Rev1 board
        - Needs connection to STM32, so the STM32 can request bitmap of SD card usage
            - Options:
                - STM32 uses MSP430 debug interface to read bitmap directly from memory
                    - Same interface used for programming MSP430
                - 3 wire SPI (chip select, clk, data)
                    - STM32 can be configured as bidirectional (SPI_CR1_BIDIMODE) so use the same line for both TX and RX
        - Needs connection to power transistors to control ICE40/RAM/SD power rails
        - Needs connection to motion detector
        - Needs to be programmable from STM32
        - Needs to be debuggable from STM32
    
    - Add power domain control
        - Controlled by MSP430
    
    - Remove analog switches between SD card and ICE40
        - They present too much capacitance
        - (U11 SD_DATx pins are out of order on Rev3)

- Preorder parts to de-risk
    - STM32
        - 90x (STM32F730I8K6) from Farnell UK
            $6.03 each
            - Try ordering 10 more from export.farnell.com in a week
        - 10x (STM32F723IEK6 -- more expensive but pin-compatible) from Mouser
            - Haven't ordered yet -- want to try ordering 10 more of the cheaper model first
    
    - ICE40
        - 100x from DigiKey
    
    - AR0330CS
    
    - MSP430
    
    - SDRAM
        W989D6DBGX6I        512 Mbit
        AS4C8M16MSA-6BIN    128 Mbit
    
    - Motion sensor

- Future
    
    - Consider using a HyperRAM instead of SDRAM
        - Pros:
            - Fewer pins: only 24 pins instead of 54 SDRAM pins
            - Doesn't need explicit refreshes, which simplifies RAMController Verilog
            - Appears to have lower power consumption
                - HyperRAM W956D8MBYA: 25 mA @ 200 MHz, VCC=2.0V
                - AS4C8M16MSA SDRAM: 75 mA @ ? MHz, VCC=1.8V
                - W989D6DBGX6I: 75 mA @ ? MHz, VCC=1.8V
        
        - Cons:
            - Requires DDR signals to operate
            - Unsure if ICE40 DDR outputs can operate fast enough
                - Image sensor output = 12 bits @ 98 MHz == 1.176e9 bits/sec
                - Clock setups:
                    - Scheme50: HyperRAM clock @ 50 MHz -> 50e6 * 8 (bits per transfer) * 2 (transfers per clock) == .8e9 bits/sec (🚫 not fast enough)
                        - DDR signals switch at 2x -> 100 MHz
                    - Scheme75: HyperRAM clock @ 75 MHz -> 75e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.2e9 bits/sec (👍 fast enough)
                        - DDR signals switch at 2x -> 150 MHz (😬 not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                    - Scheme90: HyperRAM clock @ 90 MHz -> 90e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.44e9 bits/sec (👍 fast enough)
                        - DDR signals switch at 2x -> 180 MHz (😬 not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                - Even if we can squeak by with Scheme75/Scheme90 with 12-bit pixels, we probably couldn't with 14-bit pixels (which we might want to some day)
                - From the "iCE40 LP/HX Family Data Sheet":
                    - Maximum sysIO Buffer Performance:
                        - LVCMOS18: 155 MHz
                            - Therefore, don't feel confident that we can DDR outputs at more than 155 MHz
    
    - Figure out battery power supply
        - How many batteries?
        - What battery voltage range? .8-1.7V per battery?
        - Optimize efficiency
        - Use Webench to optimize efficiency, if it supports the power ICs that we choose
            - Note that Webench doesn't support all available TI ICs, eg TPS61200
    
    - Length match traces going to RAM
    
    - Length match traces going to image sensor
    
    - Add MOSFET power transistors to define power domains
    
    - An eMMC (such as iNAND 7250, see datasheet in notes dir) might consume less power / be more reliable than an SD card. We can likely write to them faster (and maybe initialize them faster), so even if their current usage is higher, they may end up using less energy for the same operation if we can get the operation completed faster than with an SD card.
    
    - SDRAM: for proper power-up, we may need a pulldown on cs_ and pullups on ras_/cas_/we_, since power is supposed to be applied while the input signals are in the NOP state.
    
    - Add USB inrush protection
    
    - Add system-level ESD protection
        From MSP430 datasheet:
            System-level ESD protection must be applied in compliance with the device-level ESD specification
            to prevent electrical overstress or disturbing of data or code memory. See MSP430 System-Level
            ESD Considerations for more information.
            
            Search for document titled: "MSP430 System-Level ESD Considerations"
    
    - Improve current sense resistor
        - Use low-tempco resistor
        - Change value to .2Ω or .1Ω (depending on current range)




- Image pipeline todo

    - Speed up pipeline, especially Defringe and FFCC (illuminant estimation) stages
        - Currently the whole pipeline can take ~200ms
    
    - Train FFCC (illuminant estimation) with more data and better data
    
    - Improve highlight reconstruction
        - In some cases HR makes some regions worse than if it didn’t kick in at all
        - Highlights in the sky can be particularly bad -- it replaces large regions with blocks of white. 
    
    - Re-calculate color correction matrices
        - Use real color checker
        - Use a spectrometer to measure color checker squares
        - Remember that our current CCMs are calculated by averaging the identity matrix with the calculated CCM
            - We did this because it improves the output (at least when using our laser-jet printout of the colorchecker)
        
        - We should have more than 2 CCMs, and interpolate between the 2 that are the closest match
          to a illuminant (as determined by the illuminant estimation algorithm)
    
    - Implement auto exposure / exposure correction in image pipeline
        - Determine the distribution of pixel brightness, and apply some function to spread out the
          brightness distribution across the entire range
        - See:
            https://twitter.com/CSProfKGD/status/1374463703345590272
            https://github.com/mahmoudnafifi/Exposure_Correction
    
    - Correct fixed-pattern noise
        http://www.moria.de/tech/image-sensors/preparation/
        - Saved as "ImageSensors-NoiseFiltering.webarchive"
        - If you set inttime=0, fixed pattern noise seems to be maximized
    
    - Implement dead pixel correction
    
    √ Implement more sophisticated white balance for Defringe filter
        - To operate correctly, the raw data input into the Defringe filter needs to be white-balanced.
        - Currently, we're just white balancing using hard-coded constants, but that probably doesn't
          work well with all illuminants.
    
    √ Implement auto white balance (AWB)
        - Apply as very first stage (before defringing and debayering)
            - Defringe needs white-balanced image, so it makes sense to apply WB before defringing
