- Misc
    - Order more ICE40s
        - It looks like Mouser will have ICE40HX8K-BG121 in stock in October 2022
    
    - Order TPS62A01DRLR from ti.com
    
    - Buy TagConnect cable (TC2030-IDC-NL) and grips
        https://www.tag-connect.com/product/tc2030-idc-nl
        https://www.tag-connect.com/product/grip-6-3-pack



- Rev6 Board
    
    - Make new TagConnect part that doesn't have the holes on the bottom
    
    - Check/correct SD trace lengths
    
    - Layout: Add soldermask markings for VDD / GND battery terminal leads
    
    - Layout: Add soldermask markings for STM32 header pins, if we keep the header (since we want to make backside thinner)
    
    - Layout: We should be able to make the board smaller by rotating the SD card holder 90 degrees, so that the SD
      card sticks out the side of the board



- Rev6 Board Done
    
    √ Check/correct RAM trace lengths
    
    √ Check/correct IMG trace lengths
    
    √ Verify that the new ICE40 pin assignment meets our timing (since we moved the pins since Rev5 to
      account miswiring the flash chip)
          √ Need to update Pins.pcf to do this testing
    
    √ Replace STM32 header with 6-pin TagConnect
    
    √ Replace battery connector with a smaller version
    
    √ Move battery connector to the front of the board
    
    √ Replace lens holder with the 18mm version
    
    √ Layout: move USB-C connector to the front of the board so the battery can sit flush with the back
    
    X Fix: USB C connector mount point collides with lens holder plastic (see lens holder's keepout region)
        - Not an issue in practice
    
    √ Replace U8 with a reliable 2.8V buck
        - U8: voltage selection is sporadic. It seems the 'R2D converter' can fail to choose the right voltage
          in our system because of either: slow rise of VDD_B (due to U1 slow start), or because when
          power-cycling the device, it never actually turns off because VDD_B never drains
              - Adding a voltage divider (56k,20k) to the enable pins seems to fix it
                  - Rationale: Ven = 3.8*(20/(56+20)) = 1V -> VDD_B needs to reach 3.8V before U8 turns on,
                    presumably because the added delay allows the R2D converter to function correctly
                
                  X Nevermind, it's broken again after soldering the image sensor + motion sensor (now it's 3V instead of 2.8V)
        
        - Good options:
            - DIODESINC AP3429AKTTR-G1
                - Stock: none
            - TI TLV62568A-DRL
                - Stock:
                    - ti.com
    
    √ Make STM nets consistently named 'STM', not ST; eg 'ICE_ST_FLASH_EN' needs renaming

    X We should be able to make the board smaller by removing the footprint for the motion sensor, and just
      using through-hole wires to connect to it. The motion sensor will likely need to be raised up in the
      final product, since the lens is longer than the motion sensor, therefore we'll need wires to connect
      to the board anyway.
          - Nevermind, we're planning to have motion sensor be mounted to the board
    
    √ Have STM control the VDD_B_X_EN rails directly, to clean up MSP's host-mode logic
        - MSP would control the VDD_B_X_EN rails with a weak pullup/pulldown. When STM is powered, it would control the rails with strong push/pull.
        - Rationale: we have a complicated host mode based on conflicting facts:
            1. MSP needs to be running to keep track of time,
            2. MSP rails need to be controlled via SBW/JTAG
            3. MSP rails are reset when connecting/disconnecting SBW/JTAG
        - To validate this idea, make sure MSP430 can pull up a net while connected to a high-Z STM GPIO
            √ We know it can because it's currently able to pullup the HOST_MODE_ net
                - Takes 1.74µs for MSP to pullup HOST_MODE_ net to 90% of its VDD (3.3V)

    √ Combine rails since they're always on at the same time:
        - VDD_B_1V8_IMG & VDD_B_1V8_SD
        - VDD_B_2V8_IMG & VDD_B_2V8_SD
    
    √ Consider adding a pull-down to VDD_B_EN to ensure the input isn't floating when MSP430 isn't powered
      (eg when it crashes and restarts, or when it hasn't been programmed)
    
    √ U3: needs to be powered by VDD_A, not VDD_A_3V3, because the voltage on Q1's Vgate needs to reach its
      Vsource when Q1 is supposed to be off. But if U3 is powered by VDD_A_3V3, the max voltage that U3 can
      output is 3.3V, which is less than VDD_A. As currently implemented, Q1 can never be fully turned off.
    
    √ Bug: MSP430 browns-out when asserting VDD_B_EN
        - Solution: make R4 a higher value to slow Q1 turn-on and decrease inrush current
        - 100Ω: 1.21V droop
        - 1kΩ: .77V droop
        - 10kΩ: .074V droop
            - 10k seems to work well
        - We should use the same resistor value for Q4 right?
            X Nevermind, Q4 no longer exists
    
    √ Bug: U16 level shifter that controls MSP_TEST / MSP_RST_ causes MSP_RST_ to be driven low when
      connecting device to USB power. It appears this is because the STM32 side, MSP_RST_X_, is
      floating before STM32 explicitly configures the GPIO, which the level shifter interprets as a
      low value, and drives MSP_RST_ low, causing MSP430 to be reset until STM32 drives MSP_RST_X_ high.
      This appears to happen despite MSP430's pull-up on its RST pin.
      
      √ Solution: connect U16.OE to a STM32 GPIO (instead of VDD_B_1V8_STM), perhaps called 'MSP_SBW_EN',
        and include a pull-down resistor. That way, U16 outputs will be disabled until STM32 explicitly
        wants to talk to MSP430 (by asserting MSP_SBW_EN), and so MSP_RST_ won't be affected until then.
    
    √ Add a open-drain signal from STM -> MSP, which MSP observes to prevent itself from running when STM32 asserts
        √ Done: added MSP_EN signal
        - MSP should use its internal pullup, and STM should drive to ground
    
    √ Bug: BAT_CHRG_LVL voltage divider resistance is too high for STM32 ADC input resistance
        - STM32 datasheet says maximum R_AIN is 50kΩ
        √ Fixed: added a capacitor at the ADC input to act as low-impedance charge storage
    
    √ Bug: BAT_CHRG_LVL_EN_ is subjecting STM32 to the battery voltage when STM32 is off,
      which is > the absolute maximum input voltage on FT pins of VDD+4.0
        √ Fixed: replaced transistor with 74LVC1G98GW, acting as a buffer
    
    √ Rev5 bug: ICE40.K9 needs to be connected to ICE40FLASH.DI so that ICE40 can send read commands to flash
        - Constraints:
            - STM32.D0 = ICE40FLASH.DO = ICE40.SI
            - STM32.DX = ICE40FLASH.DI = ICE40.SO
        
        - Regimes:
            - STM32 programs ICE40RAM
                - STM32.D0 = ICE40.SI
            - STM32 programs ICE40FLASH
                - ICE40FLASH.DI = STM32.DX1
                - ICE40FLASH.DO = STM32.DX2
            - ICE40 boot
                - ICE40.SI = ICE40FLASH.DO
                - ICE40.SO = ICE40FLASH.DI
        
        - Therefore:
            - ICE40.SI = ICE40FLASH.DO = STM32.DX2 = STM32.D0
            - ICE40.SO = ICE40FLASH.DI = STM32.DX1 = STM32.D6
    
    √ Why is one of the ICE40 LEDs off?
        - LED is bad
    
    √ U14 pin 1 doesn't seem to be connected to VDD_A_3V3. Only explanation seems to be that there's an
      internal board crack, because VDD_A_3V3 has the correct voltage elsewhere on the board.
        - The STM32 previously enumerated via USB, so this used to work.
        √ Solution: don't rapidly change the temp of the board eg by adding flux or rinsing in alcohol!


- Software / Firmware Todo
    
    - MSPApp: while running on battery power with CurrentRanger monitoring, after some time the current
      consumption jumped from ~8µA to ~150µA, apparently not due to motion. Was this due to RTC timer
      waking us up? If so, why didn't we go back to sleep into LPM3.5?
    
    - MSPApp: store oldest 3 aborts, and newest 3 aborts (currently we only store the oldest 3 aborts)
    
    - MDCStudio: add inspector sidebar
    
    - MSPApp: Improve exposure/gain algs
    
    - MSPApp: Optimize battery usage
        - Measure current during with various rails enabled and make sure it's what we expect
        - Currently we keep VDD_B on all the time!
    
    - Make sure that IMG i2c lines are 0V while IMG power is off
        - On Rev4, ImgI2CMaster.v writes clkOut<=1 in its Idle state, so it's being driven when IMG is powered off
    
    - Patch icepack to specify frequency=high in bitstream
        - Doesn't look like there's a way to specify that in the command line options
    
    - Replace uses of RefCounted with just std::shared_ptr with a custom deleter?
      For example, there's no need to make syscalls to retain/release an io_service_t,
      when we can just use regular memory management right?
    
    - MDCStudio/STMApp: Implement battery voltage monitoring
    
    - ImagePipeline: improve perf so that we process each thumbnail in realtime to avoid slowing image loading more than the data transfer speed
        - Ie, make sure the bottleneck remains the data transfer
            - We transfer data at 42525582 bytes/sec -> /373760 == 113.778 thumbnails/sec -> 1/113.778 == 8.789 ms/thumbnail
            - Therefore ImagePipeline needs to process every image in less than 8.789ms
            - Currently ImagePipeline takes 9-12ms per thumbnail
        
        - ImagePipeline bottlenecks appear to be:
            - FFCC (takes 9.8 ms / thumbnail)
            - LMMSE (1.2 ms / thumbnail)
            - Remainder of ImagePipeline (2 ms / thumbnail)
            - Checksum validation (0.429687 ms / thumbnail)
    
    - ImagePipeline: FFCC:
        - Create new training set
            - Use color checker with known colors
                - We could either:
                    - Measure the colors ourself, or
                    - Use a colorchecker with guaranteed colors

            - Capture lots of different lighting conditions

            - Capture images with the color checker illuminated by the primary illuminant (ie not in a shadow)

            - Black-out color checker in images

            - Ensure there aren't common elements in each image (eg Sue holding the color checker)
    
    - ImagePipeline: Improve highlight reconstruction
        - In some cases HR makes some regions worse than if it didn’t kick in at all
        - Highlights in the sky can be particularly bad -- it replaces large regions with blocks of white. 
    
    - ImagePipeline: Re-calculate color correction matrices
        - Use real color checker
        - Use a spectrometer to measure color checker squares
        - Remember that our current CCMs are calculated by averaging the identity matrix with the calculated CCM
            - We did this because it improves the output (at least when using our laser-jet printout of the colorchecker)
    
        - We should have more than 2 CCMs, and interpolate between the 2 that are the closest match
          to a illuminant (as determined by the illuminant estimation algorithm)
    
    - ImagePipeline: Implement auto exposure / exposure correction in image pipeline
        - Determine the distribution of pixel brightness, and apply some function to spread out the
          brightness distribution across the entire range
        - See:
            https://twitter.com/CSProfKGD/status/1374463703345590272
            https://github.com/mahmoudnafifi/Exposure_Correction
    
    - ImagePipeline: Correct fixed-pattern noise
        http://www.moria.de/tech/image-sensors/preparation/
        - Saved as "ImageSensors-NoiseFiltering.webarchive"
        - If you set inttime=0, fixed pattern noise seems to be maximized
    
    - ImagePipeline: Implement dead pixel correction
    
    - MDCStudio: ImageGridView: thumbnail resize
        - Use LayerScrollView -magnifyIncrease: / -magnifyDecrease: interface
        - Add slider somewhere?
    
    - MDCStudio: ImageGridView: allow arrow keys to extend the current selection when holding shift/command
        - We need sophisticated handling similar to the Finder, but we should be able to do better
    
    - MDCStudio: image rotation
        - from grid view
        - from image view
    
    - MDCStudio: ImageGridView: allow enter key to open image
    
    - MDCStudio: ImageGridView: zoom animation when entering image view
    
    - MDCStudio: image exporting
    
    - MDCStudio: image drag/drop
        - to other apps
        - to existing library
        - to new library
    
    - MDCStudio: deleting images
        - show per-device trash can when images are deleted
    
    - MDCStudio: implement inspector
    
    - STMApp: occasionally aborts in _SDInit -> USBSendStatus() because the endpoint isn't ready
        - Haven't been able to determine cause yet
    
    - STMApp: reconsider whether we should be using Task::Stop() to abort tasks that are in progress.
      for example, a task might be in the middle of executing SDCard::Disable(), which isn't designed to be aborted half way through
    
    - MSPApp: make sure SysTick (WDT) doesn't wake us from LPM3.5
    
    - Test _State.img.ringBuf/_State.img.ringBuf2 resiliency to power loss
    
    - STMApp: enumeration failed in this scenario: MDC plugged in -> comp sleep -> comp wake -> "invalid endpoint 0x81"
    
    - Task.h: debug feature: stack traces
    
    - MSPApp: can we use the 'restart' facility of reset_register to speed up integration time changes?
        - 'restart' triggers a bad frame, so experiment with the 'restart_bad' and 'mask_bad' flags too
    
    - Fix bug: Without STLink connected, sometimes STApp crashes when plugging in
        - One cause is because Img::Sensor::Init() failed, because of an IMG I2C error
            - Might be because we're not waiting long enough after turning on the power rails to do I2C comms
                - "#warning TODO: measure how long it takes for IMG rails to rise"
    
    - USB Throughput, revisted:
        - Could we use the DMA "Double-buffer mode" to avoid CPU intervention between sending 64k chunks?
    
    - USB Throughput: Try to optimize USB throughput beyond 355e6 bits/sec
        - Does the USB hub limit the data throughput?
        - Perf debugging tactic: check how often the DIEPINT.NAK interrupt occurs when sending mass data to the
          host (signifying the host requesting data, but the device saying it doesn't have any)
        - Sometimes the USB Tx FIFO is empty -- we're not filling it fast enough
        - Try speeding up USB transfers by trying different values of GAHBCFG.HBSTLEN
        - When we're done sending a transfer, the ST APIs have to call out to our user code.
            - Not sure if this can be improved when DMA=1, since we can only send data from a single address at a time?
            - When DMA=0, couldn't this be improved, since we can get an interrupt when the TXFIFO is half-full,
              and start enqueueing more data from an arbitrary address?

- Future
    
    - Consider switching to a different PMOS power transistor that has ESD protection
        - Currently, our MOSFETs don't have ESD protection, so the ones that face external ports need discrete protection,
          such as the ones in the reverse polarity protection subcircuit
        
        - For example:
            - PMPB15XP
                - 1.5 kV ESD protection
                - rRDS = 19mΩ
            
            - PMPB20XPE
                - 2.4 kV ESD protection
                - rRDS = 23.5mΩ
    
    - Consider using a HyperRAM instead of SDRAM
        - Pros:
            - Fewer pins: only 24 pins instead of 54 SDRAM pins
            - Doesn't need explicit refreshes, which simplifies RAMController Verilog
            - Appears to have lower power consumption
                - HyperRAM W956D8MBYA: 25 mA @ 200 MHz, VCC=2.0V
                - AS4C8M16MSA SDRAM: 75 mA @ ? MHz, VCC=1.8V
                - W989D6DBGX6I: 75 mA @ ? MHz, VCC=1.8V
        
        - Cons:
            - Requires DDR signals to operate
            - Unsure if ICE40 DDR outputs can operate fast enough
                - Image sensor output = 12 bits @ 98 MHz == 1.176e9 bits/sec
                - Clock setups:
                    - Scheme50: HyperRAM clock @ 50 MHz -> 50e6 * 8 (bits per transfer) * 2 (transfers per clock) == .8e9 bits/sec (🚫 not fast enough)
                        - DDR signals switch at 2x -> 100 MHz
                    - Scheme75: HyperRAM clock @ 75 MHz -> 75e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.2e9 bits/sec (👍 fast enough)
                        - DDR signals switch at 2x -> 150 MHz (😬 not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                    - Scheme90: HyperRAM clock @ 90 MHz -> 90e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.44e9 bits/sec (👍 fast enough)
                        - DDR signals switch at 2x -> 180 MHz (😬 not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                - Even if we can squeak by with Scheme75/Scheme90 with 12-bit pixels, we probably couldn't with 14-bit pixels (which we might want to some day)
                - From the "iCE40 LP/HX Family Data Sheet":
                    - Maximum sysIO Buffer Performance:
                        - LVCMOS18: 155 MHz
                            - Therefore, don't feel confident that we can DDR outputs at more than 155 MHz
    
    - Figure out battery power supply
        - How many batteries?
        - What battery voltage range? .8-1.7V per battery?
        - Optimize efficiency
        - Use Webench to optimize efficiency, if it supports the power ICs that we choose
            - Note that Webench doesn't support all available TI ICs, eg TPS61200
    
    - Length match traces going to RAM
    
    - Length match traces going to image sensor
    
    - An eMMC (such as iNAND 7250, see datasheet in notes dir) might consume less power / be more reliable than an SD card. We can likely write to them faster (and maybe initialize them faster), so even if their current usage is higher, they may end up using less energy for the same operation if we can get the operation completed faster than with an SD card.
    
    - SDRAM: for proper power-up, we may need a pulldown on cs_ and pullups on ras_/cas_/we_, since power is supposed to be applied while the input signals are in the NOP state.
    
    - Add USB inrush protection
    
    - Add system-level ESD protection
        From MSP430 datasheet:
            System-level ESD protection must be applied in compliance with the device-level ESD specification
            to prevent electrical overstress or disturbing of data or code memory. See MSP430 System-Level
            ESD Considerations for more information.
            
            Search for document titled: "MSP430 System-Level ESD Considerations"
    
    - Improve current sense resistor
        - Use low-tempco resistor
        - Change value to .2Ω or .1Ω (depending on current range)
