- Rev4 Todo
    
    - MSPApp: add proper error handling to Img/SD
        - Make error handler a template parameter
        - Have error handler take a breadcrumb value
    
    - Task.h: debug feature: stack traces
    
    - MSPApp: can we use the 'restart' facility of reset_register to speed up integration time changes?
        - 'restart' triggers a bad frame, so experiment with the 'restart_bad' and 'mask_bad' flags too
    
    - MSPApp: when an error occurs, trigger a BOR
        - "In an application, it may be desired to cause a BOR in software. Setting PMMSWBOR
           causes a softwaredriven BOR. PMMBORIFG is set accordingly. Note that a BOR also initiates a POR and PUC.
           PMMBORIFG can be cleared by software or by reading SYSRSTIV."
    
    - Fix bug: Without STLink connected, sometimes STApp crashes when plugging in
        - One cause is because Img::Sensor::Init() failed, because of an IMG I2C error
            - Might be because we're not waiting long enough after turning on the power rails to do I2C comms
                - "#warning TODO: measure how long it takes for IMG rails to rise"
    
    - USB Throughput, revisted:
        - Could we use the DMA "Double-buffer mode" to avoid CPU intervention between sending 64k chunks?
    
    - USB Throughput: Try to optimize USB throughput beyond 355e6 bits/sec
        - Does the USB hub limit the data throughput?
        - Perf debugging tactic: check how often the DIEPINT.NAK interrupt occurs when sending mass data to the
          host (signifying the host requesting data, but the device saying it doesn't have any)
        - Sometimes the USB Tx FIFO is empty -- we're not filling it fast enough
        - Try speeding up USB transfers by trying different values of GAHBCFG.HBSTLEN
        - When we're done sending a transfer, the ST APIs have to call out to our user code.
            - Not sure if this can be improved when DMA=1, since we can only send data from a single address at a time?
            - When DMA=0, couldn't this be improved, since we can get an interrupt when the TXFIFO is half-full,
              and start enqueueing more data from an arbitrary address?
    
    √ MSPApp: there's some bug where the LED stays lit for much longer than it should.
        √ is Task::Sleep() sleeping too long due to a race condition?
            - Should be fixed by Toastbox commit a5b9f73
    
    √ Buy TPS2116DRLR on Mouser?
        1580 Expected 2/3/2022
        3630 Expected 3/7/2022
    
    √ STLoader/STApp: rename MSP430 -> MSP430JTAG? MSPJTAG?
    
    √ STLoader/STApp: move target-specific USB.cpp into USBBase.h
        - We just need to supply the USB descriptor to USBBase right?
    
    √ STLoader/STApp: get abort to blink LEDs even before the system is initialized,
      so that there's a clear sign of failure even if the failure occurs early in
      system startup
    
    √ STApp: migrate to use real threads
    
    √ STApp: replace uses of HAL_Delay with Scheduler::Sleep
    
    √ STLoader: cleanup
    
    √ STLoader/STApp: make BufQueue fully templated on the buffers themselves
    
    √ STLoader/STApp: make QSPI a template
    
    √ STLoader: replace uses of HAL_Delay with Scheduler::Sleep
    
    √ STLoader: migrate to use real threads
    
    √ Task.h: debug feature: detecting stack overflows
        √ Include support for detecting stack overflows on the main stack too, due to interrupt handlers using lots of stack
    
    √ MSPApp: make SD::Card / Img::Sensor / ICE classes templated
    
    √ MSPApp: we should initialize the image sensor and SD card in parallel to save time
        - protothreads? cooperative threads?
    
    √ MSPApp: Implement power-saving version of delayUs/delayMs that uses the timer peripheral, and makes the CPU go to sleep
    
    √ MSPApp: don't wait for SD/IMG to be initialized in _SetSDImgEnabled(); only wait for them when we actually need to use them
    
    X MSPApp: move _SDTask/_ImgTask into SDCard.h and ImgSensor.h
    
    √ MSPApp: add SleepMs/SleepUs functions to Scheduler
    
    √ MSPApp: Make SDCard/ImgSensor take a Scheduler template parameter
    
    √ MSPApp: migrate implementation to use real threads
    
    √ STLoader: fix issue where MDCUtil's 'mspload' can't get MSP430 to run program if CCS previously loaded a program that entered LPM3.5
    
    √ MSPApp: Set initial exposure before we start streaming, so we don't need to skip a frame on the first one
    
    √ MSPApp: use skipCount=0 for the first frame, assuming setting the exposure before streaming starts is kosher
    
    X MSPApp: is there a way to make MDCUtil cause a full MSP430 reset when doing a mspload?
        - Currently after doing a mspload, PMMIFG.PMMLPM5IFG=1, so it's not a full reset
        - Also, the RTC peripheral doesn't get reset, so if it was previously running, it continues running
        - ReleaseDevice_430Xv2() mentions BOR, does our MSP430 support it?
        - Remove ColdStart() FRAM check if this works
        X No way to issue a full reset, since some RTC/PMM registers are only reset on an actual brownout, not a BOR
            - https://e2e.ti.com/support/microcontrollers/msp-low-power-microcontrollers-group/msp430/f/msp-low-power-microcontroller-forum/1061452/msp430fr2422-full-reset-including-rtc
    
    √ STLoader: cleanup tasks the way we did for STApp
    
    √ STApp / STLoader: in cases where the device reboots (STLoader: `STMReset` command,
      STApp: `Bootloader` command), can we wait until the host receives the command
      acceptance to actually reset, so the host doesn't get an error for the command?
          √ Implemented
    
    √ Fix bug: With STLink connected, sometimes the USB device doesn't enumerate when connecting the USB cable
        - Solutions:
            √ when USB is re-connected, have USB require an acknowledgement (USB::connect()) before
              permitting USB transactions
                - if a USB method is called before the acknowledgement, short-circuit / return an error
            
            √ when USB is disconnected (suspended), reset the USB stack
            
            X keep ints disabled while running tasks
                - have QSPI ready() poll the hardware register, instead of relying on
                  ints, so that ints don't need to be enabled
                    - we should be able to delete the _busy flag
                    - we should be able to delete HAL_QSPI_CmdCpltCallback() etc
        
        - Reasons not to have ints disabled while tasks are running:
            - HAL_Delay() is broken when ints are disabled
                - We'll lose track of time if ints are disabled for longer than 1ms
            - QSPI needs ints to be enabled for the QSPI::wait() (and the _busy flag) to work correctly
                - We might be able to work around this though
    
    √ ICEAppMSP: optimize perf back to previous levels
        √ Option1: Have ImgController write in full blocks
        X Option2: Bring back small state machine and trigger SD DatOut when r_thresh ('is 1 entire block available?') is asserted, but SDController monitors r_ready ('is any data available?')
        X ImgController: try going back to registering solution, instead of connecting RAMController directly to readout port?
    
    X ImgController: configure whether readout is stopped automatically or continues indefinitely?
        √ We ended up modifying ImgController to hard-code the image and readout lengths, so
          now ICEApp controls how much data is read out, ensuring that it's over the AFIFOChain
          read threshold, thereby fixing the ImgReadoutToSPI hang issue
        X Allowing readout to continue indefinitely would fix the ImgReadoutToSPI hang issue,
          caused by the 8x FIFO not being half full
        X If we allow it to continue indefinitely, can it be reset properly?
    
    √ ICEApp: fix simulation warning:
        /home/dave/repos/MDC/Code/ICE40/Shared/ImgController.v:72: warning: Port 3 (cmd_block) of RAMController expects 11 bits, got 1.
        /home/dave/repos/MDC/Code/ICE40/Shared/ImgController.v:72:        : Padding 10 high bits of the port.
    
    √ AFIFOChain: the r_thresh signal can't be in the r_clk domain for the ReadoutToSPI cases,
      because STM32 won't be driving the clock while it's waiting for data to become available.
      So we need an async version of the signal, along with synchronous versions for internal use.
    
    √ Investigate: why did ICEAppMSP design size balloon?
        - What did it used to be?
            - As a result of using the 8x AFIFO chain in ICEAppMSP, the design went from: 2735 (35%) -> 3661 (47%) LUTs
        - Is it just AFIFOChain?
            - Yes
    
    √ ICEApp.v: consider removing readout FIFO from ImgController, and replace with FIFO chain
        - This would clean up the design because in the ICEApp_ImgReadoutToSPI_En case, ImgController
          has a readout FIFO, which is connected directly to the AFIFO chain, so it's redundant.
        √ This might allow us to remove ImgController's `readout_start` signal (which controls
          SDController.datOut_trigger) in favor of using the FIFO chain's `readoutfifo_prop_r_ready`
          signal instead, since the purpose of `readout_start` is to signal when there's enough
          data in the FIFO such that SDController can start writing
          
            √ We ended up removing readout_start
            
            X Use a FIFO chain with 2x FIFOs in this case, so that `readoutfifo_prop_r_ready`
              signifies that 512 bytes are available (ie 1 complete SD block)
            
                X Nevermind, we're using the full 8x FIFOs and sticking with the strategy
                  where SDController checks for any data being available to write, instead
                  of checking whether a full block is available.
        
        √ We'll probably need to add a `readout_rst` signal to clear the output FIFO
            - This is nice because it mirror's SDController's `datInWrite_rst`
            √ We ended up adding a readout_rst signal
            X Assert readout_rst when capturing an image, not upon readout, so that the FIFO is
              guaranteed empty when we start readout?
                X But that breaks the case where we perform successive readouts without capturing.
        
        √ Does this speed up the affected designs (ICEAppMSP / ICEAppImgCaptureSTM)?
            √ It did increase perf somewhat
    
    √ Investigate: ImgController: reconsider whether we should hard-code the ImageSize for readout purposes
        - If we allow readout to be configured to continue indefinitely, then we don't need to hardcode the image size
        √ Switched back to previous strategy where we readout the number of words that we counted during capturing
    
    √ Investigate: ImgController: does `ctrl_readoutCount` underflow when simulating ICEAppMSP?
        X No, it doesn't
        - Why does it underflow when running `./Sim.sh ICEAppImgCaptureSTM` ? ("[ImgController] ctrl_readoutCount: 1507")
            - Because ImgController doesn't transition to the "Ctrl_State_Readout+2" state until the FIFO is full,
              and it keeps getting drained because of the 8x AFIFO chain
    
    √ Add checksum to the end of images
        - Ended up using Fletcher-32 checksum.
            - Ideally we'd use a CRC, but we can't because they're computed a bit at a time,
              and our data is incoming at 16-bits per clock. So we use a checksum instead
              since it can be computed a 16-bit word at a time.
    
    √ ICEAppMSP: add image counter to image header, so software can keep track of which images have already been downloaded
    
    √ ICEAppMSP: re-implement capturing the CMD6 access mode
    
    √ ICEAppMSP
        √ Reset SDController DatOut before a new capture starts filling the FIFO
        X ImgController: stop reading from RAM beyond the last image pixel
            - Nevermind, it requires too much combinational logic without any benefit of doing so.
              We would only want to do this if it would save us from writing an additional SD block,
              but it doesn't, so it's not worth the complexity and perf slowdown.
    
    √ STLoader / STApp: add ability to reset DataIn endpoint, which sends 2 ZLPs + sentinel
        √ Automatically reset each time we send the SDRead command
        X Should every command that sends data automatically reset the DataIn endpoint? For example, what about STLoader commands that send data?
            X No, only reset at the beginning of comms. Otherwise it adds a lot of overhead.
            √ Quantify: how much overhead does it add to send the reset sequence (2 ZLPs + sentinel)?
                - Without reset sequence:   180 us
                - With reset sequence:      422 us
    
    √ STLoader / STApp: Move commands to default control endpoint
        - This will save space in the limited FIFO RAM
        - This will also help improve our command/response scheme since EP0 gets replies for every request
    
    √ SDController: Implement SD card reading
        - Requirements
            √ Read 512x1 transfers (for CMD6)
            √ Read 4096xN transfers (for reading mass data)
            √ Stop clock between N blocks if the FIFO doesn't have space
                - Clock requirements
                    - Internal: Manual control of sd_clk (for LVS init sequence)
                    - External: Switch between clk_slow and clk_fast (after initializing SD card)
                    - Internal: Disable sd_clk output (to delay reading until space is available)
            √ Always write into FIFO when doing DatIn
            √ Reset FIFO when performing new DatIn transfer
            √ Move CMD6 access mode detection to client so ICEAppMSP can keep track of it, instead of SDController
    
    √ Figure out STApp/ICEAppSTM SD data comms scheme
        - Requirements
            √ Start SD data transfer
                √ Use regular messages
            √ Terminate SD data transfer
                √ Use chip select
            √ Signal whether SD data is available
                √ Use separate pin
                - Use ICE_ST_SPI_D0
                    - Problem: ICE_ST_SPI_Dx uses clocked registers, so a clock is needed to change their value
                    - Solutions:
                        - Use OUTPUT_ENABLE, which isn't clocked
                            - STM32: enable pull-down resistor
                            - ICE40: OUTPUT_ENABLE=1
                            - ICE40: drive ICE_ST_SPI_D0 low to remove remaining voltage
                            - ICE40: OUTPUT_ENABLE=0
                            - ICE40: spi_doutReg=~0
                            - ICE40: wait for data available
                            - ICE40: OUTPUT_ENABLE=1
                        
                        - Switch ice_st_spi_d's OUTPUT_CLK
                            - Glitching could be an issue
    
    √ Get saving images to SD card working, especially with LVS SD initialization
        √ Working at 50MHz, need to try at higher frequencies
        √ Working at 102MHz. Not stress tested yet though -- may need to tweak delay.
    
    √ Get LVS SD initialization test working
        - Determined that:
            - SD card samples all signals (sd_cmd+sd_dat[3:0]), so all 5 signals need to be driven to 0V
            - SD card samples signal levels at negative edge of sd_clk, so they need to be driven
              a little longer than the negative edge.
            - SD card drives sd_dat[2] 33us after the negative edge of sd_clk, so we need to stop
              driving lines before then
            - See SDCard-LVSInitialization.png
    
    √ Get MSP430 comms working with ICE40
    
    √ Get crystal working with MSP430
    
    √ STLoader: add interface for writing MSP430 firmware
        √ We ended up overhauling everything and didn't end up adding a new interface, but MSP430 flashing is working well
    
    √ Don't we need to tell the image sensor the input frequency?
        Yes, updated image sensor configuration in MDCDevice.h
    
    √ Verify that image sensor clock is blocked when the rails are off
    
    √ Get image streaming to Mac working
        √ ICEStreamApp
    
    √ Update ICE40 to use 16 MHz clock, instead of 24 MHz
    
    √ Fix MSP_RST_/MSP_TEST logic levels
        *** Before bodging, just try programming MSP first. It's possible that 1.8V will meet MSP's Vih ***
            XXX JTAG doesn't work
        √ Option: add 10k resistor pullups to VDD_A, remove 1nF capacitor + 47k resistor, and have STM32 use open-drain signalling
            Works!
        - Option: Sever the MSP_RST_/MSP_TEST connections to MSP, wire them to MSPLevelShifter, then wire the output back to the MSP_RST_/MSP_TEST pins?
        - Option: Bodge STM_LED0/STM_LED1 -> MSPLevelShifter -> MSP_RST_/MSP_TEST
    
    √ Get programming MSP430 from STM32 working
    
    √ Verilog: Rename PIX -> IMG
    
    √ Get RAM working with ICE40
        √ RAMReadWriteTest
        √ RAMReadWriteRandomlyTest
    
    √ Verilog: Update SDRAM controller for new part (Winbond -> Alliance)
    
    √ Fix MSP level shifter net names on schematic:
        √ ICE_MSP_SPI_CLK is actually ICE_MSP_SPI_DATA
        √ ICE_MSP_SPI_DATA is actually ICE_MSP_SPI_CLK
    
    √ Swap motion sensor VDD/GND pins when soldering
    
    √ Update STM32 to use 16 MHz clock, instead of 24 MHz
    
    √ Bodge VDD_A to 2V8 so that MSP430 is powered properly
    
    √ Test whether we can get LVS identification working
        - It works!
        - See SDLVSTest-Scheme5
        - Need to implement in SDController.v
    
    √ We may need to speed up pix_dclk to get some more headroom to comfortably hit 108MHz
        √ Optimizing highlight/shadow counting appears to help significantly. Options:
            √ 1. Add pipelining, particularly the `fifoIn_write_trigger && !fifoIn_x && !fifoIn_y` boolean chain. Store that boolean in a register to be read on the next clock cycle
            2. Move highlight/shadow counting out of PixController and into a separate command issued to ICE40, specifically for calculating stats on the image stored in RAM
    
    X If we end up removing SD card pullups in favor of ice40 internal ones:
        - Make sure these pullups are enabled on the SB_IO instantiation
            - Nevermind, we kept the pullups




- Rev4 Board Test Checklist
    - Verify that the clock-blocking buffer blocks the clock to IMG when VDD_1V9_IMG=0
    
    - Verify that when battery powered:
        VDD_A = VDD_BAT
        VDD_B = HiZ / VDD_BAT (controlled by MSP)
    
    - Verify that when USB powered:
        VDD_A = 1.9V
        VDD_B = VDD_USB - V_diode_forward ~= 4.5V





- Future
    
    - Add a zener diode to VDD_BAT_IN to protect from over-voltage
        - Zeners have significant leakage though. Use a mosfet instead?
    
    ? Add a zener diode to VDD_USB_IN to protect from over-voltage
    
    - Consider using a HyperRAM instead of SDRAM
        - Pros:
            - Fewer pins: only 24 pins instead of 54 SDRAM pins
            - Doesn't need explicit refreshes, which simplifies RAMController Verilog
            - Appears to have lower power consumption
                - HyperRAM W956D8MBYA: 25 mA @ 200 MHz, VCC=2.0V
                - AS4C8M16MSA SDRAM: 75 mA @ ? MHz, VCC=1.8V
                - W989D6DBGX6I: 75 mA @ ? MHz, VCC=1.8V
        
        - Cons:
            - Requires DDR signals to operate
            - Unsure if ICE40 DDR outputs can operate fast enough
                - Image sensor output = 12 bits @ 98 MHz == 1.176e9 bits/sec
                - Clock setups:
                    - Scheme50: HyperRAM clock @ 50 MHz -> 50e6 * 8 (bits per transfer) * 2 (transfers per clock) == .8e9 bits/sec (🚫 not fast enough)
                        - DDR signals switch at 2x -> 100 MHz
                    - Scheme75: HyperRAM clock @ 75 MHz -> 75e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.2e9 bits/sec (👍 fast enough)
                        - DDR signals switch at 2x -> 150 MHz (😬 not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                    - Scheme90: HyperRAM clock @ 90 MHz -> 90e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.44e9 bits/sec (👍 fast enough)
                        - DDR signals switch at 2x -> 180 MHz (😬 not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                - Even if we can squeak by with Scheme75/Scheme90 with 12-bit pixels, we probably couldn't with 14-bit pixels (which we might want to some day)
                - From the "iCE40 LP/HX Family Data Sheet":
                    - Maximum sysIO Buffer Performance:
                        - LVCMOS18: 155 MHz
                            - Therefore, don't feel confident that we can DDR outputs at more than 155 MHz
    
    - Figure out battery power supply
        - How many batteries?
        - What battery voltage range? .8-1.7V per battery?
        - Optimize efficiency
        - Use Webench to optimize efficiency, if it supports the power ICs that we choose
            - Note that Webench doesn't support all available TI ICs, eg TPS61200
    
    - Length match traces going to RAM
    
    - Length match traces going to image sensor
    
    - Add MOSFET power transistors to define power domains
    
    - An eMMC (such as iNAND 7250, see datasheet in notes dir) might consume less power / be more reliable than an SD card. We can likely write to them faster (and maybe initialize them faster), so even if their current usage is higher, they may end up using less energy for the same operation if we can get the operation completed faster than with an SD card.
    
    - SDRAM: for proper power-up, we may need a pulldown on cs_ and pullups on ras_/cas_/we_, since power is supposed to be applied while the input signals are in the NOP state.
    
    - Add USB inrush protection
    
    - Add system-level ESD protection
        From MSP430 datasheet:
            System-level ESD protection must be applied in compliance with the device-level ESD specification
            to prevent electrical overstress or disturbing of data or code memory. See MSP430 System-Level
            ESD Considerations for more information.
            
            Search for document titled: "MSP430 System-Level ESD Considerations"
    
    - Improve current sense resistor
        - Use low-tempco resistor
        - Change value to .2Ω or .1Ω (depending on current range)




- Image pipeline todo

    - Speed up pipeline, especially Defringe and FFCC (illuminant estimation) stages
        - Currently the whole pipeline can take ~200ms
    
    - Train FFCC (illuminant estimation) with more data and better data
    
    - Improve highlight reconstruction
        - In some cases HR makes some regions worse than if it didn’t kick in at all
        - Highlights in the sky can be particularly bad -- it replaces large regions with blocks of white. 
    
    - Re-calculate color correction matrices
        - Use real color checker
        - Use a spectrometer to measure color checker squares
        - Remember that our current CCMs are calculated by averaging the identity matrix with the calculated CCM
            - We did this because it improves the output (at least when using our laser-jet printout of the colorchecker)
        
        - We should have more than 2 CCMs, and interpolate between the 2 that are the closest match
          to a illuminant (as determined by the illuminant estimation algorithm)
    
    - Implement auto exposure / exposure correction in image pipeline
        - Determine the distribution of pixel brightness, and apply some function to spread out the
          brightness distribution across the entire range
        - See:
            https://twitter.com/CSProfKGD/status/1374463703345590272
            https://github.com/mahmoudnafifi/Exposure_Correction
    
    - Correct fixed-pattern noise
        http://www.moria.de/tech/image-sensors/preparation/
        - Saved as "ImageSensors-NoiseFiltering.webarchive"
        - If you set inttime=0, fixed pattern noise seems to be maximized
    
    - Implement dead pixel correction
    
    √ Implement more sophisticated white balance for Defringe filter
        - To operate correctly, the raw data input into the Defringe filter needs to be white-balanced.
        - Currently, we're just white balancing using hard-coded constants, but that probably doesn't
          work well with all illuminants.
    
    √ Implement auto white balance (AWB)
        - Apply as very first stage (before defringing and debayering)
            - Defringe needs white-balanced image, so it makes sense to apply WB before defringing
