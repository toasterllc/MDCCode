- Rev6
    
    - Bug: MSP430 browns-out when asserting VDD_B_EN
        - Solution: make R4 a higher value to slow Q1 turn-on and decrease inrush current
    
    - Bug: U16 level shifter that controls MSP_TEST / MSP_RST_ causes MSP_RST_ to be driven low when
      connecting device to USB power. It appears this is because the STM32 side, MSP_RST_X_, is
      floating before STM32 explicitly configures the GPIO, which the level shifter interprets as a
      low value, and drives MSP_RST_ low, causing MSP430 to be reset until STM32 drives MSP_RST_X_ high.
      This appears to happens despite MSP430's pull-up on its RST pin.
      
      - Solution: connect U16.OE to a STM32 GPIO (instead of VDD_B_1V8_STM), perhaps called 'MSP_SBW_EN',
        and include a pull-down resistor. That way, U16 outputs will be disabled until STM32 explicitly
        wants to talk to MSP430 (by asserting MSP_SBW_EN), and so MSP_RST_ won't be affected until then.
    
    - Verify that the new ICE40 pin assignment meets our timing (since we moved the pins since Rev5 to
      account miswiring the flash chip)
          - Need to update Pins.pcf to do this testing
    
    - Make STM nets consistently named 'STM', not ST; eg 'ICE_ST_FLASH_EN' needs renaming
    
    - U8: voltage selection is sporadic. It seems the 'R2D converter' can fail to choose the right voltage
      in our system because of either: slow rise of VDD_B (due to U1 slow start), or because when
      power-cycling the device, it never actually turns off because VDD_B never drains
          - Adding a voltage divider (56k,20k) to the enable pins seems to fix it
              - Rationale: Ven = 3.8*(20/(56+20)) = 1V -> VDD_B needs to reach 3.8V before U8 turns on,
                presumably because the added delay allows the R2D converter to function correctly
    
    - U3: needs to be powered by VDD_A, not VDD_A_3V3, because the voltage on Q1's Vgate needs to reach its
      Vsource when Q1 is supposed to be off. But if U3 is powered by VDD_A_3V3, the max voltage that U3 can
      output is 3.3V, which is less than VDD_A. As currently implemented, Q1 can never be fully turned off.
    
    - Consider adding a pull-down to VDD_B_EN to ensure the input isn't floating when MSP430 isn't powered
      (eg when it crashes and restarts, or when it hasn't been programmed)
    
    - Fix: USB C connector mount point collides with lens holder plastic (see lens holder's keepout region)
    
    - We should be able to make the board smaller by rotating the SD card holder 90 degrees, so that the SD
      card sticks out the side of the board
    
    - We should be able to make the board smaller by removing the footprint for the motion sensor, and just
      using through-hole wires to connect to it. The motion sensor will likely need to be raised up in the
      final product, since the lens is longer than the motion sensor, therefore we'll need wires to connect
      to the board anyway.
    
    âˆš Rev5 bug: ICE40.K9 needs to be connected to ICE40FLASH.DI so that ICE40 can send read commands to flash
        - Constraints:
            - STM32.D0 = ICE40FLASH.DO = ICE40.SI
            - STM32.DX = ICE40FLASH.DI = ICE40.SO
        
        - Regimes:
            - STM32 programs ICE40RAM
                - STM32.D0 = ICE40.SI
            - STM32 programs ICE40FLASH
                - ICE40FLASH.DI = STM32.DX1
                - ICE40FLASH.DO = STM32.DX2
            - ICE40 boot
                - ICE40.SI = ICE40FLASH.DO
                - ICE40.SO = ICE40FLASH.DI
        
        - Therefore:
            - ICE40.SI = ICE40FLASH.DO = STM32.DX2 = STM32.D0
            - ICE40.SO = ICE40FLASH.DI = STM32.DX1 = STM32.D6
    
    âˆš Why is one of the ICE40 LEDs off?
        - LED is bad
    
    âˆš U14 pin 1 doesn't seem to be connected to VDD_A_3V3. Only explanation seems to be that there's an
      internal board crack, because VDD_A_3V3 has the correct voltage elsewhere on the board.
        - The STM32 previously enumerated via USB, so this used to work.
        âˆš Solution: don't rapidly change the temp of the board eg by adding flux or rinsing in alcohol!

- Rev5
    
    - Cancel order for TPS62802YKAR / TPS63805YFFR if we no longer need it
    
    - MSP430: If we need more FRAM/SRAM, replace MSP430FR2422 (8KB FRAM, 2KB SRAM) -> MSP430FR2433 (16KB FRAM, 4KB SRAM)
    
    - Make sure that IMG i2c lines are 0V while IMG power is off
        - On Rev4, ImgI2CMaster.v writes clkOut<=1 in its Idle state, so it's being driven when IMG is powered off
    
    - Patch icepack to specify frequency=high in bitstream
        - Doesn't look like there's a way to specify that in the command line options
    
    - Replace uses of RefCounted with just std::shared_ptr with a custom deleter?
      For example, there's no need to make syscalls to retain/release an io_service_t,
      when we can just use regular memory management right?




- Rev5 Done
    
    âˆš Make sure all capacitors / resistors have part numbers
    
    âˆš Order stencils
    
    âˆš Order parts
    
    âˆš Re-synthesize with new ICE40 pin locations to make sure everything works
    
    âˆš When complete, make sure board origin is at 0,0
    
    âˆš Make board left/right borders smaller
    
    âˆš Layout!
    
    âˆš Make sure y position of motion sensor and image sensor are equal
    
    âˆš Verify lengths of IMG_ and SD_ nets
    
    âˆš Buy more TPS62802 if needed
        - Supposed to be delivered 10/2022
    
    âˆš Length-match IMG wires
    
    âˆš Length-match SD wires
    
    âˆš Correct (swap) ICE SPI flash's data in/out pins so that by default, the flash is ready to
      be read by ICE40, but STM32 can program it by bit-banging ICE_ST_SPI_D0 / ICE_ST_SPI_D1
    
    X Connect ICE40 VPP_2V5 to 3V3 instead of 2V8 if it helps us, since we're no longer
      going to be doing NVCM Programming we're not limited by the 3V max voltage anymore
      
      X Nevermind, this would require an additional load switch, since VDD_A_3V3 is our
        3V3 rail, and it's part of the VDD_A power domain, which is always on, so it
        can't be connected to VPP_2V5 without gating it on VDD_B.
    
    âˆš USB C jack: figure out what to do with: CC1/CC2/SBU1/SBU2
        - CC1/CC2: 5.1k pulldowns
        - SBU1/SBU2: unconnected
    
    âˆš Verify that slots for USB-C jack footprint are recognized by OSH-Park
    
    âˆš Switch USB receptacle to USB-C
    
    âˆš Add battery terminal
    
    âˆš Consider moving ICE_MSP_SPI_DATA to K3
        - On Rev4, ICE_MSP_SPI_DATA is assigned to K1, which is a PIO pair with J1,
          forcing them to share the same clock. J1 is ram_dq[15], which uses `ram_clk`,
          which clearly can't be used for ICE_MSP_SPI_DATA.
          
        - We can move ICE_MSP_SPI_DATA to K3 if we don't need ICE_MSP_SPI_AUX
            - K3 doesn't share a PIO with anything -- it's independent
    
    âˆš Move ICE_MSP_SPI_CLK to K2 to be closer to ICE_MSP_SPI_DATA, also free up K1
      (which is high-value since it's on the edge)
    
    âˆš Create new connection:
        - Name:     ICE_ST_SPI_D_READY
        - Between:  ICE40.L5 <-> STM32.R3
        - Purpose:  Signals that SD data is ready to be read from ICE40
    
    âˆš Connect to STM32: BAT_CHRG_STAT, BAT_CHRG_LVL, BAT_CHRG_LVL_EN_
        - So STM32 can monitor charging status
    
    âˆš Add ESD protection diode to MOSFET gate
    
    âˆš Add bypass caps to all new components
        âˆš Flash: W25Q40EWUXIE
        âˆš Battery charger: MCP73831
        âˆš Power mux: TPS2116
        âˆš LDO: AP7350-33CF4-7
        âˆš Level shifters: NXP-NTB0102
    
    X Measure inrush current to see if it's in-spec since we're using multiple 10uF capacitors on VDD_USB
        X Nevermind, after reading the following, 10uF limit makes sense:
            https://electronics.stackexchange.com/questions/36375/understanding-usb-inrush-current-requirements
        
        - We have several 10u capacitors on VDD_USB, which is more than the USB spec allows (max 10uF),
          but that's OK if the inrush current isn't exceeded
    
    âˆš Add reverse current protection for VDD_A_3V3 LDO
        - Consider case: input power is instantly disconnected, so Vout>Vin. Do we need to protect LDO from reverse current?
            - From TPS7A02 datasheet: "This reverse current flow can cause damage to the device."
    
    âˆš Add flash for ICE40 (instead of using NVCM)
        - W25Q40EWUXIE looks good (DigiKey)
    
    âˆš Add LDO to provide VDD_A_3V3
        - AP7350-33CF4-7 looks like a good option
            - Vout = 3.3V
            - Iout,max = 150mA
            - Iq = .25ÂµA
    
    âˆš Add LIPO charger circuit
        âˆš MCP73831
        - DIO5518B
        - DIO5508CD10
    
    âˆš Add reverse polarity protection in case the battery is inserted backwards:
        https://www.analog.com/media/en/technical-documentation/application-notes/an-171_an-1568.pdf
        Use PMOS design
    
    âˆš Add TPS2116 power mux to switch between USB power and battery power
    
    âˆš Replace TPS63805 power supply with TPS62802, outputting 2.8V
    
    âˆš Remove ICE_MSP_SPI_DATA_DIR now that we have the direction-sensing level shifters
    
    âˆš For VDD_A, is it more efficient to use an LDO or a buck (TPS62802)?
        - LDO!
            - LDO wastes: Pwaste = (Vin-Vout)*Iout + Vin*Iq
                - Vin=4.2, Vout=3.6, Iout=5ÂµA, Iq=.5uA: (4.2-3.6)*(5ÂµA) + 4.2*(.5ÂµA) = 5.1ÂµW
                - Vin=3.7, Vout=3.6, Iout=5ÂµA, Iq=.5uA: (3.7-3.6)*(5ÂµA) + 3.7*(.5ÂµA) = 2.35ÂµW
                - Vin=3.7, Vout=3.3, Iout=5ÂµA, Iq=.5uA: (3.7-3.3)*(5ÂµA) + 3.3*(.5ÂµA) = 3.65ÂµW
            - Buck wastes: Pwaste = Vout*Iout*((1/Eff)-1) =
                - Vout=4.2, Iout=5ÂµA, Eff=.2: 4.2*(5ÂµA)*((1/.2)-1) = 0.000084 = 84ÂµW
                - Vout=3.6, Iout=5ÂµA, Eff=.2: 3.6*(5ÂµA)*((1/.2)-1) = 0.000072 = 72ÂµW
    
    âˆš Fix motion sensor layout (we swapped the VDD and GND pins)
    
    âˆš Consolidate parts
        âˆš 249k resistor? (replace with 422k, since it just needs to be >= 249k)
        âˆš 4.7uF capacitor (2-3x 2.2uF)
        X 3k resistor (?)
            X We're not using 1k resistors
        X 91k resistor
            X We can't afford to let the 2V8 rail stray from its current value
        X 422k resistor
            X We can't afford to let the 2V8 rail stray from its current value
    
    âˆš Replace 0-ohm resistors with solder jumpers
    
    âˆš Switch 1V9 back to 1V8, now that we've solved the SD card Vih by using LVS
    
    âˆš Switch crystal to use Q13FC13500005 (ordered 110x from LCSC)
        âˆš Also update 2x crystal capacitors -- see CrystalLoadCapacitanceCalculations.txt
        - See CrystalPartOptions.txt for other parts
    
    âˆš Fix power system to ensure that reverse current into battery/USB isn't possible
        - Things to test:
            - Ramp up USB (BAT) while BAT (USB) is already supplying power
                - Reverse current?
            - Plug in USB (BAT) while BAT (USB) is already supplying power, where USB (BAT) < BAT (USB)
                - Reverse current?
            - Plug in USB (BAT) while BAT (USB) is already supplying power, where USB (BAT) > BAT (USB)
                - Reverse current?
            - Disconnect USB (BAT) while USB (BAT) is supplying power
                - In other words, disconnect the power source that is supply power
                - Reverse current?
            - Disconnect USB (BAT) while BAT (USB) is supplying power
                - In other words, disconnect the power source that isn't supply power
                - Reverse current?
    
    âˆš Use Nexperia 74LVC1G98GW,125 logic gate for:
        âˆš IMG clock-blocking buffer (replace TI part)
        âˆš VDD_B_EN OR gate (inputs: VDD_B_EN from MSP, VDD_USB)
    
    âˆš MSP430: fix power supply, again
        âˆš Switched to a slow-on/fast-off break-before-make power rail solution
    
    âˆš MSP430: fix power supply when plugged into USB
        - Problem: MSP430 needs a voltage higher than 2V to reliably start up, due to SVS
        âˆš Solution: Replace MAX40203 with TPS706 LDO
            - LDO requirements
                - LDO input = VDD_B
                - LDO output = 2.5V - 3.3V (use >2.4V so the motion sensor is powered)
                - Needs enable, controlled by VDD_USB
                - Needs to allow output voltage to be high while LDO is off (in battery mode)
                - Needs reverse current protection (in case battery voltage is higher)
                - Can't have an output discharge circuit (otherwise it'll draw current when disabled, in battery mode)
            
            - Still need to use level shifter for MSP's TEST/RST_ nets, since MSP's Vih is
              still too high (.75*2.5=1.875, which is too high to be driven by STM running at 1.8V)
            
            - LDO options:
                TPS706
                    Input voltage: 2.7-6.5 V
                    Output voltage: 1.2-5 V
                    Enable voltage: 0-6.5 V
                    Reverse current (current flowing into OUT pin @ VOUT=3V, VIN=VEN=0V): 100nA
        
        - Solution: Make VDD_A=VDD_2V8, via MAX40203
            X This won't work in battery mode because the MAX40203's voltage input needs to be lower than the battery voltage, otherwise we'll charge the battery
            - But how do we handle STM comms since STM runs at 1.8V?
                - We can't connect directly to STM because MSP430 Vih=2.1 (>1.9V of STM) ðŸ‘Ž
                - Use level shifter. We'll need to free up a spot though
            - Confirm with simulation that the power topology still works (no reverse voltage into battery, etc)
        
        - Solution: Make power supply start at >2.1V, then settle at 1.9V
            - How do we do that?
                - Might not be possible with TPS62802 since its output levels are digitally selected, not analog
                    - We would need a variable resistence on TPS62802 MODE pin
                        - Complicated
                - Some kind of crazy charge pump circuit that's only active at power on?
    
    âˆš MSP430: fix level shifting
        - Since MSP430 is now running at 2.5V, we need to level-shift ICE_MSP_SPI_CLK/ICE_MSP_SPI_DATA and MSP_TEST/MSP_RST_
        
        - Bench-testing supply current of NTB0102
            - Supply current <5nA when A1=A2=VDDA=2.5V and B1=B2=VDDB=0V
                - Same ballpark as reported in "Typical supply current" section of the datasheet 
        
        âˆš Solution: 2x Nexperia NXB0102/NTB0102 level shifters
            - TI TXB0102 / TXB0302 would also work
                - They don't publish 'supply current' though; power consumption might be higher
            
            - Need to adjust MSP_RST_ pin:
                - Remove pullup (rely on internal ~31k pullup)
                    - Reason: Internal pullup is already on the low side, and the external one will act in parallel, reducing overall resistance further
                    - Reason: "Any pull-up or pull-down resistors used must be kept higher than 50 kÎ©"
                - Reduce capacitor to <70pF (reuse cap used elsewhere in design whatever other capacitor)
                    - Reason: "NXB0102 [can] drive capacitive loads of up to 70 pF"
            
            - MSP_RST_ Calculations
                - Because MSP430 has internal pullup (measured: 31k, datasheet: 20k-50k) that's on the low side,
                  the level shifter's VOL and MSP's VIL need to be compared.
                    - Worst case:
                        - NXB0102 output driver = 6k
                            - 6k=4k*1.5 -- assumed worst-case value; TI level shifters assume 4.5k as worst-case, so 6k is conservative
                        - MSP430 RST pullup = 20k (from datasheet)
                        - NXB0102 VOL = (6k/(20k+6k)) * 2.5V == 0.577
                        - MSP430 VIL = 0.625 (.25*2.5, from datasheet)
                        âˆš VOL=0.577 < VIL=0.625
                            - Therefore in the worst-case, NXB0102's VOL will still trigger a low value for MSP
            
            - Price
                $0.202 / channel [NTB0102]
            - Pros
                - Simple
                - Small package (2.1*2 == 4.2 mm^2)
                - 1 STM pin for MSP_RST
                - 1 ICE pin for DOUT/DIN
            - Cons
                - Low current: 10nA @ 25C
        
        - Solution: NFET/PFETs (see schematics in notebook)
            - Parts
                - PMCXB900UE / PMCXB900UEL / PMCXB1000UE
                    - Physically small (1.1 mm^2 * 4 == 4.4 mm^2 total area)
                - NTZD3155C
                    - Physically large (2.56 mm^2)
            - Price
                $0.202 / channel [PMCXB900UE]
            - Pros
                - Low leakage
                    - Most datasheets are very conservative
                    - See https://electronics.stackexchange.com/questions/98597/low-drain-source-mosfet-leakage
                    - NTND31015NZTAG -- IDSS=100pA @ 25C
                    - XLLGA6 -- IDSS=100pA @ 25C
            - Cons
                - 2 STM pins for MSP_RST_
                - 2 ICE pins for DOUT/DIN
                - Complicated: need 4x + 3-10 resistors (number of resistors depends on how fast we want rising edge to be for the various nets)
        
        - Solution: 2x Nexperia 74AVC2T245
            - Price
                $0.208 / channel
            - Pros
                - Simple
                - Smallish (2.52 mm^2 *2 == 5.04 mm^2 total area)
            - Cons
                - 2 STM pins for MSP_RST_
                - 2 ICE pins for DOUT/DIN
                - Medium current: .1 uA according to "Typical total supply current"
        
        - Solution: 4x SN74LVC1T45YZPR
            - Price
                $0.253 / channel
            - Pros
            - Cons
                - 2 STM pins for MSP_RST_
                - 2 ICE pins for DOUT/DIN
                - Medium-ish leakage current (1uA @ 25C)
        
        - Solution: 2x TI SN74AVC2T245
            - Price
                $??? / channel
            - Pros
                - Simple
            - Cons
                - 2 STM pins for MSP_RST_
                - 2 ICE pins for DOUT/DIN
                - Medium-ish leakage current (.5uA @ 25C)
                - No stock
        
        X Solution: 2x 74AVC2T45GN / 74AVC2T45GS
            X Only 1 direction pin
            - Price
                $0.14-0.16 / channel
            - Pros
                - Simple
                - Small (1.2 mm^2 *2 == 2.4x mm^2 total area)
            - Cons
                - 2 STM pins for MSP_RST_
                - 2 ICE pins for DOUT/DIN
                - Medium-ish leakage current (.5 uA @ 25C)
        
        X Solution: 74AUP1T34
            X No direction pin
            - Pros
                - Low leakage (.2uA)
            - Cons
                - Max voltage is 3.6V
        
        X Solution: use 2x SN74LVC2T45
            X Only has 1 direction pin
            - Medium-ish leakage current (1uA @ 25C)
            - One for ICE_MSP_SPI_CLK / ICE_MSP_SPI_DATA (direction controlled by MSP430)
            - One for MSP_TEST / MSP_RST_ (direction controlled by STM32)
    
    âˆš Fix MSP level shifter net names:
        - ICE_MSP_SPI_CLK is actually ICE_MSP_SPI_DATA
        - ICE_MSP_SPI_DATA is actually ICE_MSP_SPI_CLK
    
    âˆš Find solution for ICE40's VOH(min)=[1.5,1.7] < SD's VIH(min)=1.75
        âˆš Solution: only use LVS ('A2') SD cards, and implement LVS identification protocol
            âˆš Need to figure out how LVS identification works
                - Working
                    - See SDLVSTest-Scheme5
            - Pros:
                - Simple
                - Keep existing SD infrastructure
            - Cons:
                - LVS SD cards ('A2') aren't as readily available
                - LVS SD cards are more expensive
            
            - LVS cards:
                https://www.neweggbusiness.com/product/product.aspx?item=9b-20-215-138&tpk=9b-20-215-138
                https://www.neweggbusiness.com/product/product.aspx?item=9b-20-175-006&tpk=9b-20-175-006
        
        - Solution: switch to eMMC
            - For example: https://lcsc.com/product-detail/FLASH_TOSHIBA-THGBMJG6C1LBAIL_C524518.html
            - Pros:
                - No voltage switching required
            - Cons:
                - Aren't easily sourced
                - More expensive
        
        - Solution: implement voltage switching
            - We could use 2 PFETs to switch between voltages, but we'd want break-before-make
              logic, so we'd need to engineer a solution that prevents the voltage from dipping
              below 1.8V when switching the supplies.
            
            - Pros:
                - Proper solution per the SD spec
            - Cons:
                - Complicated
                    - Would require 1 or 2 more IOs to control the PFETs (either from ICE40 or MSP430)
                - Not sure if ICE40 allows VCCIO to change dynamically
        
        - Solution: do nothing and test whether ICE40's VOH is actually a problem in practice



- Software / Firmware Todo

    - MDCStudio: ImageGridView: thumbnail resize
        - Use LayerScrollView -magnifyIncrease: / -magnifyDecrease: interface
        - Add slider somewhere?
    
    - MDCStudio: ImageGridView: allow arrow keys to extend the current selection when holding shift/command
        - We need sophisticated handling similar to the Finder, but we should be able to do better
    
    - MDCStudio: image rotation
        - from grid view
        - from image view
    
    - MDCStudio: ImageGridView: allow enter key to open image
    
    - MDCStudio: ImageGridView: zoom animation when entering image view
    
    - MDCStudio: image exporting
    
    - MDCStudio: image drag/drop
        - to other apps
        - to existing library
        - to new library
    
    - MDCStudio: deleting images
        - show per-device trash can when images are deleted
    
    - MDCStudio: implement inspector
    
    - STMApp: occasionally aborts in _SDInit -> USBSendStatus() because the endpoint isn't ready
        - Haven't been able to determine cause yet
    
    - STMApp: reconsider whether we should be using Task::Stop() to abort tasks that are in progress.
      for example, a task might be in the middle of executing SDCard::Disable(), which isn't designed to be aborted half way through
    
    - MSPApp: make sure SysTick (WDT) doesn't wake us from LPM3.5
    
    - Test _State.img.ringBuf/_State.img.ringBuf2 resiliency to power loss
    
    - STMApp: enumeration failed in this scenario: MDC plugged in -> comp sleep -> comp wake -> "invalid endpoint 0x81"
    
    - Task.h: debug feature: stack traces
    
    - MSPApp: can we use the 'restart' facility of reset_register to speed up integration time changes?
        - 'restart' triggers a bad frame, so experiment with the 'restart_bad' and 'mask_bad' flags too
    
    - Fix bug: Without STLink connected, sometimes STApp crashes when plugging in
        - One cause is because Img::Sensor::Init() failed, because of an IMG I2C error
            - Might be because we're not waiting long enough after turning on the power rails to do I2C comms
                - "#warning TODO: measure how long it takes for IMG rails to rise"
    
    - USB Throughput, revisted:
        - Could we use the DMA "Double-buffer mode" to avoid CPU intervention between sending 64k chunks?
    
    - USB Throughput: Try to optimize USB throughput beyond 355e6 bits/sec
        - Does the USB hub limit the data throughput?
        - Perf debugging tactic: check how often the DIEPINT.NAK interrupt occurs when sending mass data to the
          host (signifying the host requesting data, but the device saying it doesn't have any)
        - Sometimes the USB Tx FIFO is empty -- we're not filling it fast enough
        - Try speeding up USB transfers by trying different values of GAHBCFG.HBSTLEN
        - When we're done sending a transfer, the ST APIs have to call out to our user code.
            - Not sure if this can be improved when DMA=1, since we can only send data from a single address at a time?
            - When DMA=0, couldn't this be improved, since we can get an interrupt when the TXFIFO is half-full,
              and start enqueueing more data from an arbitrary address?





- Rev4 Todo
    
    âˆš MDCStudio: implement image view
        âˆš cache: responsible for returning image if already loaded, and fetching it if not
        âˆš image provider: responsible for loading images from SD card or disk
        âˆš cache or image provider needs to handle dropping work
        âˆš when neighbor loading, new neighbor loading works should occur before existing neighbor loading, and a neighbor loading that happens later shouldn't cause an earlier cache entry to be evicted
        âˆš cache or image provider should queue work, and drop the work that's no longer needed
            âˆš eg: when user quickly flips through full-size images, lots of work would be enqueued, but we may not need the work at the end
                âˆš Priority: required, high, low
        âˆš allow arrow keys to be used to navigate to the previous/next image
            X use animation
                X animation is too distracting
        âˆš implement zooming
        âˆš implement panning
        âˆš optimize draw performance by caching full-size image texture
        âˆš draw shadow behind image
        âˆš 'size-to-fit' mode; stay in this mode until zooming manually
        âˆš keyboard zooming (cmd+, cmd-)
        âˆš mouse zooming (command-scroll)
        âˆš implement:
            - (NSRect)rectForSmartMagnificationAtPoint:(NSPoint)location inRect:(NSRect)visibleRect API_AVAILABLE(macos(10.8));
        âˆš latch pan/zoom mode when -scrollWheel: starts, so we can't flip between scrolling and zooming
    
    âˆš MDCStudio: use LayerScrollView / MetalScrollLayer for ImageGridView
    
    âˆš MDCStudio: merge ImageGridLayer into ImageGridView, the same as we did for ImageView
    
    âˆš MDCStudio: create ImageSource that wraps ImageCache+ImageLibrary, and pass that around
    
    âˆš MDCStudio: implement grid view selection
        âˆš Arrow key selection modification
            âˆš Scroll view focus should follow selection
        âˆš Select-all
        âˆš Shift/command selection to add/remove selected items
        âˆš Drag-select should autoscroll the scroll view
    
    âˆš MDCStudio: switch to delegate model:
        âˆš SourceListView
        âˆš ImageGridView
        X ResizerView
    
    âˆš MDCStudio: prevent selection layer from being clipped
    
    âˆš MDCStudio: make device names editable
    
    âˆš MDCStudio: make document based
    
    âˆš MDCStudio: implement device list sidebar
    
    âˆš MDCStudio: draw line between source list and content view
    
    âˆš MDCStudio: ImageLibrary.h: add ability to observe changes, so that we can update the grid
    
    âˆš MDCStudio: corrupt images appear after: initial load ; exit MDCStudio ; icewrite ; mspreadstate ; take more photos ; relaunch MDCStudio
    
    âˆš STMApp: ICEWrite fails on the second invocation
    
    âˆš MDCStudio: fix artifacts when resizing window
    
    âˆš MDCStudio: first draw of grid layer is weird
    
    X MDCStudio: MDCDevice.h: make sure we sync _imgLib _before_ writing imgIdEnd, to guarantee _imgLib.back.id >= imgIdEnd,
      so if we crash between writing the IL and writing imgIdEnd, we can recover if we see that imgIdEnd < _imgLib.back.id
        âˆš We ended up closely coupling ImageLibrary with RecordStore -- they now both write their state to the same file
    
    X MDCStudio: MDCDevice.h: if imgIdEnd < _imgLib.back.id, update imgIdEnd = _imgLib.back.id
        âˆš We shouldn't need to worry about this anymore now that ImageLibrary and RecordStore are closely coupled
    
    X MDCStudio: figure out a locking scheme so that MDCDevice.h and ImageLibrary.h share a lock
        âˆš They shouldn't need to share a lock anymore, now that we've closely coupled ImageLibrary and RecordStore
    
    âˆš ImageLibrary: what happens if: Thread2: reserve() ; Thread1: remove(), sync() ; Thread2: add()
        - We now forbid calling sync() between the reserve() / add() calls
    
    âˆš MSPApp: if MSPApp aborts, ICE40 will be in an unknown state. so when cold-starting,
      we should explicitly disable both Img and SD.
        - This is only necessary for the current design where ICE40 needs to keep running.
          In the future ICE40 power will be controlled by MSP430 and therefore will automatically reset.
    
    âˆš STMApp: get compiling again after Task/SDCard/etc changes
    
    âˆš MSPApp: test capturing images / get working again
    
    âˆš ICEAppSim: implement `sdClkObserved` without killing performance
    
    âˆš MSPApp: upon a cold start (which includes aborts) or if _state.sd.valid==false, refresh the SD card ID (CID). If the CID doesn't match the one stored in MSP::State, reset the ring buffers / capacity
    
    âˆš MSPApp: delay before actual abort, so we don't restart too quickly if too many aborts happen too quickly
    
    âˆš Let RTC run even if startTime is invalid? it would be nice if abort events have a non-zero time, even if it's not correct
    
    âˆš MSPApp: make FRAM data structure resilient to power loss during modifications
        - Strategy:
            - Have 2 copies of the `img` data structure
            - Use a checksum, and use the one with the greatest `count` that also has a valid checksum
    
    âˆš MSPApp: update img ring buffer data structure properly when captuing image
    
    âˆš MSPApp: add ability to read FRAM regions
        - necessary for:
            - setting MSP time
            - reading image ring buffer
            - writing image ring buffer
            - setting SD card size / ring buffer size
        - have a shared header containing the data structures
    
    âˆš MSPApp: when an error occurs, trigger a BOR
        - "In an application, it may be desired to cause a BOR in software. Setting PMMSWBOR
           causes a softwaredriven BOR. PMMBORIFG is set accordingly. Note that a BOR also initiates a POR and PUC.
           PMMBORIFG can be cleared by software or by reading SYSRSTIV."
    
    âˆš MSPApp: add proper error handling to Img/SD
        - Make error handler a template parameter
        - Have error handler take a breadcrumb value
        - Store abort history in a persistent data structure
    
    âˆš MSPApp: there's some bug where the LED stays lit for much longer than it should.
        âˆš is Task::Sleep() sleeping too long due to a race condition?
            - Should be fixed by Toastbox commit a5b9f73
    
    âˆš Buy TPS2116DRLR on Mouser?
        1580 Expected 2/3/2022
        3630 Expected 3/7/2022
    
    âˆš STLoader/STApp: rename MSP430 -> MSP430JTAG? MSPJTAG?
    
    âˆš STLoader/STApp: move target-specific USB.cpp into USBBase.h
        - We just need to supply the USB descriptor to USBBase right?
    
    âˆš STLoader/STApp: get abort to blink LEDs even before the system is initialized,
      so that there's a clear sign of failure even if the failure occurs early in
      system startup
    
    âˆš STApp: migrate to use real threads
    
    âˆš STApp: replace uses of HAL_Delay with Scheduler::Sleep
    
    âˆš STLoader: cleanup
    
    âˆš STLoader/STApp: make BufQueue fully templated on the buffers themselves
    
    âˆš STLoader/STApp: make QSPI a template
    
    âˆš STLoader: replace uses of HAL_Delay with Scheduler::Sleep
    
    âˆš STLoader: migrate to use real threads
    
    âˆš Task.h: debug feature: detecting stack overflows
        âˆš Include support for detecting stack overflows on the main stack too, due to interrupt handlers using lots of stack
    
    âˆš MSPApp: make SD::Card / Img::Sensor / ICE classes templated
    
    âˆš MSPApp: we should initialize the image sensor and SD card in parallel to save time
        - protothreads? cooperative threads?
    
    âˆš MSPApp: Implement power-saving version of delayUs/delayMs that uses the timer peripheral, and makes the CPU go to sleep
    
    âˆš MSPApp: don't wait for SD/IMG to be initialized in _SetSDImgEnabled(); only wait for them when we actually need to use them
    
    X MSPApp: move _SDTask/_ImgTask into SDCard.h and ImgSensor.h
    
    âˆš MSPApp: add SleepMs/SleepUs functions to Scheduler
    
    âˆš MSPApp: Make SDCard/ImgSensor take a Scheduler template parameter
    
    âˆš MSPApp: migrate implementation to use real threads
    
    âˆš STLoader: fix issue where MDCUtil's 'mspload' can't get MSP430 to run program if CCS previously loaded a program that entered LPM3.5
    
    âˆš MSPApp: Set initial exposure before we start streaming, so we don't need to skip a frame on the first one
    
    âˆš MSPApp: use skipCount=0 for the first frame, assuming setting the exposure before streaming starts is kosher
    
    X MSPApp: is there a way to make MDCUtil cause a full MSP430 reset when doing a mspload?
        - Currently after doing a mspload, PMMIFG.PMMLPM5IFG=1, so it's not a full reset
        - Also, the RTC peripheral doesn't get reset, so if it was previously running, it continues running
        - ReleaseDevice_430Xv2() mentions BOR, does our MSP430 support it?
        - Remove ColdStart() FRAM check if this works
        X No way to issue a full reset, since some RTC/PMM registers are only reset on an actual brownout, not a BOR
            - https://e2e.ti.com/support/microcontrollers/msp-low-power-microcontrollers-group/msp430/f/msp-low-power-microcontroller-forum/1061452/msp430fr2422-full-reset-including-rtc
    
    âˆš STLoader: cleanup tasks the way we did for STApp
    
    âˆš STApp / STLoader: in cases where the device reboots (STLoader: `STMReset` command,
      STApp: `Bootloader` command), can we wait until the host receives the command
      acceptance to actually reset, so the host doesn't get an error for the command?
          âˆš Implemented
    
    âˆš Fix bug: With STLink connected, sometimes the USB device doesn't enumerate when connecting the USB cable
        - Solutions:
            âˆš when USB is re-connected, have USB require an acknowledgement (USB::connect()) before
              permitting USB transactions
                - if a USB method is called before the acknowledgement, short-circuit / return an error
            
            âˆš when USB is disconnected (suspended), reset the USB stack
            
            X keep ints disabled while running tasks
                - have QSPI ready() poll the hardware register, instead of relying on
                  ints, so that ints don't need to be enabled
                    - we should be able to delete the _busy flag
                    - we should be able to delete HAL_QSPI_CmdCpltCallback() etc
        
        - Reasons not to have ints disabled while tasks are running:
            - HAL_Delay() is broken when ints are disabled
                - We'll lose track of time if ints are disabled for longer than 1ms
            - QSPI needs ints to be enabled for the QSPI::wait() (and the _busy flag) to work correctly
                - We might be able to work around this though
    
    âˆš ICEAppMSP: optimize perf back to previous levels
        âˆš Option1: Have ImgController write in full blocks
        X Option2: Bring back small state machine and trigger SD DatOut when r_thresh ('is 1 entire block available?') is asserted, but SDController monitors r_ready ('is any data available?')
        X ImgController: try going back to registering solution, instead of connecting RAMController directly to readout port?
    
    X ImgController: configure whether readout is stopped automatically or continues indefinitely?
        âˆš We ended up modifying ImgController to hard-code the image and readout lengths, so
          now ICEApp controls how much data is read out, ensuring that it's over the AFIFOChain
          read threshold, thereby fixing the ImgReadoutToSPI hang issue
        X Allowing readout to continue indefinitely would fix the ImgReadoutToSPI hang issue,
          caused by the 8x FIFO not being half full
        X If we allow it to continue indefinitely, can it be reset properly?
    
    âˆš ICEApp: fix simulation warning:
        /home/dave/repos/MDC/Code/ICE40/Shared/ImgController.v:72: warning: Port 3 (cmd_block) of RAMController expects 11 bits, got 1.
        /home/dave/repos/MDC/Code/ICE40/Shared/ImgController.v:72:        : Padding 10 high bits of the port.
    
    âˆš AFIFOChain: the r_thresh signal can't be in the r_clk domain for the ReadoutToSPI cases,
      because STM32 won't be driving the clock while it's waiting for data to become available.
      So we need an async version of the signal, along with synchronous versions for internal use.
    
    âˆš Investigate: why did ICEAppMSP design size balloon?
        - What did it used to be?
            - As a result of using the 8x AFIFO chain in ICEAppMSP, the design went from: 2735 (35%) -> 3661 (47%) LUTs
        - Is it just AFIFOChain?
            - Yes
    
    âˆš ICEApp.v: consider removing readout FIFO from ImgController, and replace with FIFO chain
        - This would clean up the design because in the ICEApp_ImgReadoutToSPI_En case, ImgController
          has a readout FIFO, which is connected directly to the AFIFO chain, so it's redundant.
        âˆš This might allow us to remove ImgController's `readout_start` signal (which controls
          SDController.datOut_trigger) in favor of using the FIFO chain's `readoutfifo_prop_r_ready`
          signal instead, since the purpose of `readout_start` is to signal when there's enough
          data in the FIFO such that SDController can start writing
          
            âˆš We ended up removing readout_start
            
            X Use a FIFO chain with 2x FIFOs in this case, so that `readoutfifo_prop_r_ready`
              signifies that 512 bytes are available (ie 1 complete SD block)
            
                X Nevermind, we're using the full 8x FIFOs and sticking with the strategy
                  where SDController checks for any data being available to write, instead
                  of checking whether a full block is available.
        
        âˆš We'll probably need to add a `readout_rst` signal to clear the output FIFO
            - This is nice because it mirror's SDController's `datInWrite_rst`
            âˆš We ended up adding a readout_rst signal
            X Assert readout_rst when capturing an image, not upon readout, so that the FIFO is
              guaranteed empty when we start readout?
                X But that breaks the case where we perform successive readouts without capturing.
        
        âˆš Does this speed up the affected designs (ICEAppMSP / ICEAppImgCaptureSTM)?
            âˆš It did increase perf somewhat
    
    âˆš Investigate: ImgController: reconsider whether we should hard-code the ImageSize for readout purposes
        - If we allow readout to be configured to continue indefinitely, then we don't need to hardcode the image size
        âˆš Switched back to previous strategy where we readout the number of words that we counted during capturing
    
    âˆš Investigate: ImgController: does `ctrl_readoutCount` underflow when simulating ICEAppMSP?
        X No, it doesn't
        - Why does it underflow when running `./Sim.sh ICEAppImgCaptureSTM` ? ("[ImgController] ctrl_readoutCount: 1507")
            - Because ImgController doesn't transition to the "Ctrl_State_Readout+2" state until the FIFO is full,
              and it keeps getting drained because of the 8x AFIFO chain
    
    âˆš Add checksum to the end of images
        - Ended up using Fletcher-32 checksum.
            - Ideally we'd use a CRC, but we can't because they're computed a bit at a time,
              and our data is incoming at 16-bits per clock. So we use a checksum instead
              since it can be computed a 16-bit word at a time.
    
    âˆš ICEAppMSP: add image counter to image header, so software can keep track of which images have already been downloaded
    
    âˆš ICEAppMSP: re-implement capturing the CMD6 access mode
    
    âˆš ICEAppMSP
        âˆš Reset SDController DatOut before a new capture starts filling the FIFO
        X ImgController: stop reading from RAM beyond the last image pixel
            - Nevermind, it requires too much combinational logic without any benefit of doing so.
              We would only want to do this if it would save us from writing an additional SD block,
              but it doesn't, so it's not worth the complexity and perf slowdown.
    
    âˆš STLoader / STApp: add ability to reset DataIn endpoint, which sends 2 ZLPs + sentinel
        âˆš Automatically reset each time we send the SDRead command
        X Should every command that sends data automatically reset the DataIn endpoint? For example, what about STLoader commands that send data?
            X No, only reset at the beginning of comms. Otherwise it adds a lot of overhead.
            âˆš Quantify: how much overhead does it add to send the reset sequence (2 ZLPs + sentinel)?
                - Without reset sequence:   180 us
                - With reset sequence:      422 us
    
    âˆš STLoader / STApp: Move commands to default control endpoint
        - This will save space in the limited FIFO RAM
        - This will also help improve our command/response scheme since EP0 gets replies for every request
    
    âˆš SDController: Implement SD card reading
        - Requirements
            âˆš Read 512x1 transfers (for CMD6)
            âˆš Read 4096xN transfers (for reading mass data)
            âˆš Stop clock between N blocks if the FIFO doesn't have space
                - Clock requirements
                    - Internal: Manual control of sd_clk (for LVS init sequence)
                    - External: Switch between clk_slow and clk_fast (after initializing SD card)
                    - Internal: Disable sd_clk output (to delay reading until space is available)
            âˆš Always write into FIFO when doing DatIn
            âˆš Reset FIFO when performing new DatIn transfer
            âˆš Move CMD6 access mode detection to client so ICEAppMSP can keep track of it, instead of SDController
    
    âˆš Figure out STApp/ICEAppSTM SD data comms scheme
        - Requirements
            âˆš Start SD data transfer
                âˆš Use regular messages
            âˆš Terminate SD data transfer
                âˆš Use chip select
            âˆš Signal whether SD data is available
                âˆš Use separate pin
                - Use ICE_ST_SPI_D0
                    - Problem: ICE_ST_SPI_Dx uses clocked registers, so a clock is needed to change their value
                    - Solutions:
                        - Use OUTPUT_ENABLE, which isn't clocked
                            - STM32: enable pull-down resistor
                            - ICE40: OUTPUT_ENABLE=1
                            - ICE40: drive ICE_ST_SPI_D0 low to remove remaining voltage
                            - ICE40: OUTPUT_ENABLE=0
                            - ICE40: spi_doutReg=~0
                            - ICE40: wait for data available
                            - ICE40: OUTPUT_ENABLE=1
                        
                        - Switch ice_st_spi_d's OUTPUT_CLK
                            - Glitching could be an issue
    
    âˆš Get saving images to SD card working, especially with LVS SD initialization
        âˆš Working at 50MHz, need to try at higher frequencies
        âˆš Working at 102MHz. Not stress tested yet though -- may need to tweak delay.
    
    âˆš Get LVS SD initialization test working
        - Determined that:
            - SD card samples all signals (sd_cmd+sd_dat[3:0]), so all 5 signals need to be driven to 0V
            - SD card samples signal levels at negative edge of sd_clk, so they need to be driven
              a little longer than the negative edge.
            - SD card drives sd_dat[2] 33us after the negative edge of sd_clk, so we need to stop
              driving lines before then
            - See SDCard-LVSInitialization.png
    
    âˆš Get MSP430 comms working with ICE40
    
    âˆš Get crystal working with MSP430
    
    âˆš STLoader: add interface for writing MSP430 firmware
        âˆš We ended up overhauling everything and didn't end up adding a new interface, but MSP430 flashing is working well
    
    âˆš Don't we need to tell the image sensor the input frequency?
        Yes, updated image sensor configuration in MDCDevice.h
    
    âˆš Verify that image sensor clock is blocked when the rails are off
    
    âˆš Get image streaming to Mac working
        âˆš ICEStreamApp
    
    âˆš Update ICE40 to use 16 MHz clock, instead of 24 MHz
    
    âˆš Fix MSP_RST_/MSP_TEST logic levels
        *** Before bodging, just try programming MSP first. It's possible that 1.8V will meet MSP's Vih ***
            XXX JTAG doesn't work
        âˆš Option: add 10k resistor pullups to VDD_A, remove 1nF capacitor + 47k resistor, and have STM32 use open-drain signalling
            Works!
        - Option: Sever the MSP_RST_/MSP_TEST connections to MSP, wire them to MSPLevelShifter, then wire the output back to the MSP_RST_/MSP_TEST pins?
        - Option: Bodge STM_LED0/STM_LED1 -> MSPLevelShifter -> MSP_RST_/MSP_TEST
    
    âˆš Get programming MSP430 from STM32 working
    
    âˆš Verilog: Rename PIX -> IMG
    
    âˆš Get RAM working with ICE40
        âˆš RAMReadWriteTest
        âˆš RAMReadWriteRandomlyTest
    
    âˆš Verilog: Update SDRAM controller for new part (Winbond -> Alliance)
    
    âˆš Fix MSP level shifter net names on schematic:
        âˆš ICE_MSP_SPI_CLK is actually ICE_MSP_SPI_DATA
        âˆš ICE_MSP_SPI_DATA is actually ICE_MSP_SPI_CLK
    
    âˆš Swap motion sensor VDD/GND pins when soldering
    
    âˆš Update STM32 to use 16 MHz clock, instead of 24 MHz
    
    âˆš Bodge VDD_A to 2V8 so that MSP430 is powered properly
    
    âˆš Test whether we can get LVS identification working
        - It works!
        - See SDLVSTest-Scheme5
        - Need to implement in SDController.v
    
    âˆš We may need to speed up pix_dclk to get some more headroom to comfortably hit 108MHz
        âˆš Optimizing highlight/shadow counting appears to help significantly. Options:
            âˆš 1. Add pipelining, particularly the `fifoIn_write_trigger && !fifoIn_x && !fifoIn_y` boolean chain. Store that boolean in a register to be read on the next clock cycle
            2. Move highlight/shadow counting out of PixController and into a separate command issued to ICE40, specifically for calculating stats on the image stored in RAM
    
    X If we end up removing SD card pullups in favor of ice40 internal ones:
        - Make sure these pullups are enabled on the SB_IO instantiation
            - Nevermind, we kept the pullups




- Rev4 Board Test Checklist
    - Verify that the clock-blocking buffer blocks the clock to IMG when VDD_1V9_IMG=0
    
    - Verify that when battery powered:
        VDD_A = VDD_BAT
        VDD_B = HiZ / VDD_BAT (controlled by MSP)
    
    - Verify that when USB powered:
        VDD_A = 1.9V
        VDD_B = VDD_USB - V_diode_forward ~= 4.5V





- Future
    
    - Consider switching to a different PMOS power transistor that has ESD protection
        - Currently, our MOSFETs don't have ESD protection, so the ones that face external ports need discrete protection,
          such as the ones in the reverse polarity protection subcircuit
        
        - For example:
            - PMPB15XP
                - 1.5 kV ESD protection
                - rRDS = 19mÎ©
            
            - PMPB20XPE
                - 2.4 kV ESD protection
                - rRDS = 23.5mÎ©
    
    - Consider using a HyperRAM instead of SDRAM
        - Pros:
            - Fewer pins: only 24 pins instead of 54 SDRAM pins
            - Doesn't need explicit refreshes, which simplifies RAMController Verilog
            - Appears to have lower power consumption
                - HyperRAM W956D8MBYA: 25 mA @ 200 MHz, VCC=2.0V
                - AS4C8M16MSA SDRAM: 75 mA @ ? MHz, VCC=1.8V
                - W989D6DBGX6I: 75 mA @ ? MHz, VCC=1.8V
        
        - Cons:
            - Requires DDR signals to operate
            - Unsure if ICE40 DDR outputs can operate fast enough
                - Image sensor output = 12 bits @ 98 MHz == 1.176e9 bits/sec
                - Clock setups:
                    - Scheme50: HyperRAM clock @ 50 MHz -> 50e6 * 8 (bits per transfer) * 2 (transfers per clock) == .8e9 bits/sec (ðŸš« not fast enough)
                        - DDR signals switch at 2x -> 100 MHz
                    - Scheme75: HyperRAM clock @ 75 MHz -> 75e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.2e9 bits/sec (ðŸ‘ fast enough)
                        - DDR signals switch at 2x -> 150 MHz (ðŸ˜¬ not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                    - Scheme90: HyperRAM clock @ 90 MHz -> 90e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.44e9 bits/sec (ðŸ‘ fast enough)
                        - DDR signals switch at 2x -> 180 MHz (ðŸ˜¬ not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                - Even if we can squeak by with Scheme75/Scheme90 with 12-bit pixels, we probably couldn't with 14-bit pixels (which we might want to some day)
                - From the "iCE40 LP/HX Family Data Sheet":
                    - Maximum sysIO Buffer Performance:
                        - LVCMOS18: 155 MHz
                            - Therefore, don't feel confident that we can DDR outputs at more than 155 MHz
    
    - Figure out battery power supply
        - How many batteries?
        - What battery voltage range? .8-1.7V per battery?
        - Optimize efficiency
        - Use Webench to optimize efficiency, if it supports the power ICs that we choose
            - Note that Webench doesn't support all available TI ICs, eg TPS61200
    
    - Length match traces going to RAM
    
    - Length match traces going to image sensor
    
    - An eMMC (such as iNAND 7250, see datasheet in notes dir) might consume less power / be more reliable than an SD card. We can likely write to them faster (and maybe initialize them faster), so even if their current usage is higher, they may end up using less energy for the same operation if we can get the operation completed faster than with an SD card.
    
    - SDRAM: for proper power-up, we may need a pulldown on cs_ and pullups on ras_/cas_/we_, since power is supposed to be applied while the input signals are in the NOP state.
    
    - Add USB inrush protection
    
    - Add system-level ESD protection
        From MSP430 datasheet:
            System-level ESD protection must be applied in compliance with the device-level ESD specification
            to prevent electrical overstress or disturbing of data or code memory. See MSP430 System-Level
            ESD Considerations for more information.
            
            Search for document titled: "MSP430 System-Level ESD Considerations"
    
    - Improve current sense resistor
        - Use low-tempco resistor
        - Change value to .2Î© or .1Î© (depending on current range)




- Image pipeline todo

    - Speed up pipeline, especially Defringe and FFCC (illuminant estimation) stages
        - Currently the whole pipeline can take ~200ms
    
    - Train FFCC (illuminant estimation) with more data and better data
    
    - Improve highlight reconstruction
        - In some cases HR makes some regions worse than if it didnâ€™t kick in at all
        - Highlights in the sky can be particularly bad -- it replaces large regions with blocks of white. 
    
    - Re-calculate color correction matrices
        - Use real color checker
        - Use a spectrometer to measure color checker squares
        - Remember that our current CCMs are calculated by averaging the identity matrix with the calculated CCM
            - We did this because it improves the output (at least when using our laser-jet printout of the colorchecker)
        
        - We should have more than 2 CCMs, and interpolate between the 2 that are the closest match
          to a illuminant (as determined by the illuminant estimation algorithm)
    
    - Implement auto exposure / exposure correction in image pipeline
        - Determine the distribution of pixel brightness, and apply some function to spread out the
          brightness distribution across the entire range
        - See:
            https://twitter.com/CSProfKGD/status/1374463703345590272
            https://github.com/mahmoudnafifi/Exposure_Correction
    
    - Correct fixed-pattern noise
        http://www.moria.de/tech/image-sensors/preparation/
        - Saved as "ImageSensors-NoiseFiltering.webarchive"
        - If you set inttime=0, fixed pattern noise seems to be maximized
    
    - Implement dead pixel correction
    
    âˆš Implement more sophisticated white balance for Defringe filter
        - To operate correctly, the raw data input into the Defringe filter needs to be white-balanced.
        - Currently, we're just white balancing using hard-coded constants, but that probably doesn't
          work well with all illuminants.
    
    âˆš Implement auto white balance (AWB)
        - Apply as very first stage (before defringing and debayering)
            - Defringe needs white-balanced image, so it makes sense to apply WB before defringing
