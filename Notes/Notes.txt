âˆš Rev5 Todo

    For mass production, replace the only 4.7uF 0603 capacitor with 2-3 2.2uF 0402 capacitors (which we're using elsewhere in the design)


- Additional parts to order
    Solder paste
    Jumpers


âˆš Rev4 Layout Todo
    âˆš Assign missing part numbers
    âˆš Smash every component to bring back their labels (we may have deleted some)
    âˆš Test Verilog mockup of SD card I/O to make sure new layout works with SD card
        - Tested by adding SB_IO instances to ICEStreamApp-Rotated
    âˆš Fill gaps in power layer
    âˆš Make sure we're following the layout guidelines for crystals
    âˆš Make sure we don't have any 6-mil traces
    âˆš Remove unnecessary test points
    âˆš Make sure 2x 1V2 bypass capacitors at the bottom-left of the ice40 are positioned well
    âˆš Make sure there are no parts inside the lens holder
    âˆš Make sure wires beneath motion sensor aren't at risk of being shorted to circuitry on the bottom of the motion sensor
    âˆš Add ground header?
    âˆš Make sure lens holder and motion sensor have the same Y position
    âˆš Length-match USB+/USB- lines
    âˆš Length-match STM<->ICE SPI lines
    âˆš Length-match IMG lines
    âˆš Length-match SD lines
    âˆš Length-match RAM lines
    âˆš Rotate image sensor
    âˆš Move MSP_TEST and MSP_RST_ nets to bottom-left of STM32




- Rev4 Schematic Todo
    
    âˆš Replace VDD_A/VDD_B jumpers with something that allows easy current sensing
    
    âˆš Add connector for battery pack
        Used a jumper
    
    âˆš Limit USB inrush current
        - Also make sure no one's using VDD_USB directly -- only use the inrush-limited net
        - Options:
            LM3525MX-H/NOPB
                $0.849 @ 100
            
            TPS2001DDBVT
            
            MIC94090YC6-TR
                Soft-start isn't configurable
                $0.25 @ 100
            
            TPS22919DCK
                Already using in our design
                $0.177 @ 100
    
    âˆš Update BusinessOrders.txt
    
    âˆš Compact wires going to RAM now that we no longer have an A12 net (ball G1)
    
    âˆš ICE40: Fix pin layout so that both PLLs can be used
        âˆš Fix B6 PLL: swap A6 and B6 (RAM_DQM0 is output-only)
        âˆš Fix L5 PLL
        - When a PLL is used, the tile that it's on can only be used as an output pin (not an input pin). So make PLL IO tiles either outputs, or unused
        - "PLL input path is shared with the IO input path of the IO tile it's in":
            https://freenode.irclog.whitequark.org/yosys/2019-03-13
            https://logs.timvideos.us/%23yosys/%23yosys.2019-03-13.log.html
    
    âˆš Raise 1.8V rail to 1.85-1.90V so that it's easier to meet the SD card Vih in 3.3V mode
        - Vih(2.8V) = 0.625*VDD = .625*2.8 = 1.75 V => 50mV away from 1.8V rail, 150mV away from 1.9V rail
        - MSP430        ðŸ‘  VCC: 1.8 - 3.6
        - ICE40         ðŸ‘  VCCIO I/O Driver Supply Voltage: 1.71 - 3.46
        - RAM           ðŸ‘  Supply Voltage: 1.7 - 1.95 V
        - AR0330        ðŸ‘  Digital voltage: 1.7 â€“ 1.9 V
        - SD            ðŸ‘  Input High Voltage VIH: 1.27 - 2.00 V
        - STM32         ðŸ‘  VDD: 1.7 - 3.6
        - Motion Sensor ðŸ‘ðŸ»  VDD: 2.3 - 4 (1.9V will underpower the motion sensor, but that's OK because
                            it'll only get powered by 1.9V in USB mode -- not battery mode -- and we don't
                            need the motion sensor to work in USB mode anyway. In battery mode, it'll be
                            powered by the 3V battery voltage.)
    
    âˆš STM32: Make sure we're not using any GPIOs that are powered by VDDUSB, since they'll use VDDUSB, and not 1.8V
        "VDDUSB: ... supply voltage for PA11,PA12, PB14 and PB15 pins"
    
    âˆš Add bypass capacitor to motion sensor
    
    âˆš Add bypass capacitors to MSP430
        - Reference current sensor design
        - Reference datasheet / MSP guide
    
    âˆš Add MSP430 (MSP430FR2422)
        âˆš Needs FRAM to store the bitmap of the SD card usage
        âˆš Needs connection to ICE40, to issue commands
            âˆš 2-wire SPI (clk, data): connect MSP430 MOSI/MISO together, and ensure:
                - During Tx: MOSI=Driven
                - During Rx: MOSI=HighZ
                - 2021-4-28: confirmed that this technique should work by using the CurrentSensor Rev1 board
        âˆš Needs connection to STM32, so the STM32 can request bitmap of SD card usage
            - Options:
                âˆš STM32 uses MSP430 debug interface to read bitmap directly from memory
                    - Same interface used for programming MSP430
                - 3 wire SPI (chip select, clk, data)
                    - STM32 can be configured as bidirectional (SPI_CR1_BIDIMODE) so use the same line for both TX and RX
                    - Pros:
                    - Cons:
                        - Requires extra wires
        âˆš Needs connection to power transistors to control ICE40/RAM/SD power rails
        âˆš Needs to be programmable/debuggable from STM32
            - Spy-bi-wire likely needs to be implemented by bit-banging 2 GPIOs (instead of using a
              STM32 SPI peripheral), since, with SBW, every third clock reverses the data transfer
              direction for a single clock (so that the slave can output TDO).
        âˆš Needs connection to motion detector
    
    âˆš Add motion detector
    
    âˆš Rename nets containing '24MHz' since we replaced the clock chip to be 16MHz
    
    âˆš STM32: Fix USB power supply
        - VDD_USB (ball H13) should be supplied with 3-3.6V, but for some reason we tied it to 1V8 on the Rev3 board
        âˆš Make sure to add necessary capacitors too
    
    âˆš Figure out ICE40 NVCM programming
        - We should be able to program NVCM from STM32, because:
            - NVCM is programmed using the same SPI interface used for configuring its RAM
            - We're already supplying 2.8V to ICE40's VPP_2V5, which is between the 2.3-3 V range for NVCM programming
    
    âˆš Add crystal so MSP430 can keep track of time
    
    âˆš Consider leaving MSP430 ACLK pin disconnected, so we can measure crystal frequency on it
    
    âˆš Make sure 3V3 LDO starts up after VDD_1V8_STM
    
    âˆš Add caps to 3V3 LDO output
    
    âˆš Switch RAM to ALLIANCE-AS4C8M16MSA-6BIN
    
    âˆš Replace ESD chip with DT1446-04V-7
    
    âˆš Replace load switches with TPS22919DCK
    
    âˆš Switch clocks to SIT8021AI-J4-18S-16.000000E
        - Reason: the 24 MHz version is more expensive, and Mouser doesn't have enough quantity
    
    âˆš Update image sensor part number
    
    âˆš Figure out power rails, yet again
    
    âˆš Update PFET footprint / part number
    
    âˆš Connect ICE_MSP_* nets to ICE40
    
    âˆš Simulate power supply changes to make sure it still works
        - Needed additional changes (switched back to using a diode for supplying VDDB in USB mode), but it simulates OK now
    
    âˆš Add power domain control
        - Controlled by MSP430
    
    âˆš Remove analog switches between SD card and ICE40
        - They present too much capacitance
        - (Also, U11 SD_DATx pins are out of order on Rev3)
    
    âˆš Block clock to PIX while PIX is powered down
        - Only needed if we're going to separate the PIX power domain
            - If not, PIX will always be powered if the clock is powered, so we don't need to block the clock
        X Have separate clocks for ICE and PIX, each powered by the respective power domain?
            X No, extra the clock chip is expensive, while buffers are cheap
    
    âˆš Implement PIX / SD power domains:
        âˆš Option1: separate power domains
            âˆš Description
                - PIX power and SD power are independently controlled by MSP
            
            âˆš Requirements
                âˆš Gate PIX power (PFET)
                âˆš Gate PIX clock
                    - Option1: separate clock chip with enable tied to PIX power
                    - Option2: tri-state buffer blocks clock signal while PIX isn't powered
                âˆš Gate SD power (PFET)
        
        X Option2: same power domain
            - Description
                - PIX power and SD power are the same -- they're both powered or unpowered
            
            - Requirements
                - Gate PIX clock
                    - Option1: separate clock chip with enable tied to PIX power
                    - Option2: tri-state buffer blocks clock signal while PIX isn't powered
    
    âˆš Add reverse polarity protection for the VDD_BAT
    
    âˆš Block power to STM32 when 1V8 is powered in battery mode
    
    X Consider lowering 2V8 rail to 2V7-ish, so that it's easier to meet the SD card Vih in 3.3V mode
        - Vih(2.8V) = 0.625*VDD = .625*2.8 = 1.75 V => only 50mV away from 1.8V rail
        - Vih(2.7V) = 0.625*VDD = .625*2.7 = 1.6875 V => 0.1125 => 113mV away from 1.8V rail
        X The min voltage for the image sensor is 2.76V :(
    
    X Block current into STM32's MSP_RST_ GPIO, due to the MSP_RST_ pull-up?
        - Not sure if this is necessary since the current will be small. But we should quantify how small the current is:
            - Use CurrentRanger to find out how much current enters an unpowered STM32's GPIO,
              from a 47k resistor hooked to ~3.3V. Test on Rev3 board by removing an LED. (Or
              test first without removing an LED, in case the current is small enough in that
              case, and so we don't need to remove it.)
            
            - Did testing -- STM32 GPIO consumes 83 nA when the STM32 is unpowered
        
        X Don't attempt to block the current. Most analog switches consume at least 100 nA just existing,
          so that defeats the purpose since the current we're trying to block is 83 nA.
          The only analog switch that would help is TMUX1101 (which consumes 3 nA),
          but it's expensive ($0.704 - $1.187).




- Rev4 Verilog Todo

    - Update SDRAM controller for new part (Winbond -> Alliance)
    
    - Update Verilog to use 16 MHz clock, instead of 24 MHz
    
    - If we end up removing SD card pullups in favor of ice40 internal ones:
      make sure these pullups are enabled on the SB_IO instantiation
    
    - Rename PIX -> IMG
    
    âˆš We may need to speed up pix_dclk to get some more headroom to comfortable hit 108MHz
        âˆš Optimizing highlight/shadow counting appears to help significantly. Options:
            âˆš 1. Add pipelining, particularly the `fifoIn_write_trigger && !fifoIn_x && !fifoIn_y` boolean chain. Store that boolean in a register to be read on the next clock cycle
            2. Move highlight/shadow counting out of PixController and into a separate command issued to ICE40, specifically for calculating stats on the image stored in RAM




- Rev4 Board Test Checklist
    - Verify that the clock-blocking buffer blocks the clock to IMG when VDD_1V9_IMG=0
    
    - Verify that when battery powered:
        VDD_A = VDD_BAT
        VDD_B = HiZ / VDD_BAT (controlled by MSP)
    
    - Verify that when USB powered:
        VDD_A = 1.9V
        VDD_B = VDD_USB - V_diode_forward ~= 4.5V



- Preorder parts to de-risk
    
    - EKMB1107112 (motion sensor -- need to test first before mass order)
        - Mouser in stock
    
    - STM32F730I8K6 / STM32F723IEK6 -- 15x
        - STM32F723IEK6 is more-expensive but pin-compatible with STM32F730I8K6
        - export.farnell.com
            "More stock available week commencing 28/06/21"
        - sierraic.com has stock
            - Waiting for quote for 15x
    
    âˆš Mouser
        MIC5504-3.3YM5-TR (3.3V LDO)
        MC-306 32.7680K-E3:ROHS (32 kHz crystal)
        MAX40203ANS+T (ideal diode)
        TPS62802YKAR (1.8V supply)
        TPS63805YFFR (2.8V supply)
            - sierraic.com has stock too
        BKP1005EM100-T (ferrite bead)
    
    âˆš TI
        SN74LVC1G126DCKR (clock-blocking buffer)
        TPS22919DCK / TPS22919QDCKRQ1 (load switch)
    
    âˆš Rochester
        AR0330CS1C12SPKA0-CR
    
    âˆš TI
        TPS62801YKAT (1.2V supply)
        SN74AXC4T774RSVR (level shifter)
    
    âˆš Mouser
        AS4C8M16MSA-6BIN (RAM)
        MSP430FR2422
        PMPB10UPX (PFET)
        DT1446-04V-7 (ESD chip)
        EKMB1107112 (motion sensor) -- only buy a few
        SIT8021AI-J4-18S-16.000000E
    
    âˆš DigiKey
        ICE40 (100x)
    
    âˆš Farnell UK
        STM32F730I8K6 (90x)


- Future
    
    - Add a zener diode to VDD_BAT_IN to protect from over-voltage
        - Zeners have significant leakage though. Use a mosfet instead?
            
    
    ? Add a zener diode to VDD_USB_IN to protect from over-voltage
    
    - Consider using a HyperRAM instead of SDRAM
        - Pros:
            - Fewer pins: only 24 pins instead of 54 SDRAM pins
            - Doesn't need explicit refreshes, which simplifies RAMController Verilog
            - Appears to have lower power consumption
                - HyperRAM W956D8MBYA: 25 mA @ 200 MHz, VCC=2.0V
                - AS4C8M16MSA SDRAM: 75 mA @ ? MHz, VCC=1.8V
                - W989D6DBGX6I: 75 mA @ ? MHz, VCC=1.8V
        
        - Cons:
            - Requires DDR signals to operate
            - Unsure if ICE40 DDR outputs can operate fast enough
                - Image sensor output = 12 bits @ 98 MHz == 1.176e9 bits/sec
                - Clock setups:
                    - Scheme50: HyperRAM clock @ 50 MHz -> 50e6 * 8 (bits per transfer) * 2 (transfers per clock) == .8e9 bits/sec (ðŸš« not fast enough)
                        - DDR signals switch at 2x -> 100 MHz
                    - Scheme75: HyperRAM clock @ 75 MHz -> 75e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.2e9 bits/sec (ðŸ‘ fast enough)
                        - DDR signals switch at 2x -> 150 MHz (ðŸ˜¬ not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                    - Scheme90: HyperRAM clock @ 90 MHz -> 90e6 * 8 (bits per transfer) * 2 (transfers per clock) == 1.44e9 bits/sec (ðŸ‘ fast enough)
                        - DDR signals switch at 2x -> 180 MHz (ðŸ˜¬ not sure if ICE40 DDR outputs can switch this fast)
                            - See "Maximum sysIO Buffer Performance" below
                - Even if we can squeak by with Scheme75/Scheme90 with 12-bit pixels, we probably couldn't with 14-bit pixels (which we might want to some day)
                - From the "iCE40 LP/HX Family Data Sheet":
                    - Maximum sysIO Buffer Performance:
                        - LVCMOS18: 155 MHz
                            - Therefore, don't feel confident that we can DDR outputs at more than 155 MHz
    
    - Figure out battery power supply
        - How many batteries?
        - What battery voltage range? .8-1.7V per battery?
        - Optimize efficiency
        - Use Webench to optimize efficiency, if it supports the power ICs that we choose
            - Note that Webench doesn't support all available TI ICs, eg TPS61200
    
    - Length match traces going to RAM
    
    - Length match traces going to image sensor
    
    - Add MOSFET power transistors to define power domains
    
    - An eMMC (such as iNAND 7250, see datasheet in notes dir) might consume less power / be more reliable than an SD card. We can likely write to them faster (and maybe initialize them faster), so even if their current usage is higher, they may end up using less energy for the same operation if we can get the operation completed faster than with an SD card.
    
    - SDRAM: for proper power-up, we may need a pulldown on cs_ and pullups on ras_/cas_/we_, since power is supposed to be applied while the input signals are in the NOP state.
    
    - Add USB inrush protection
    
    - Add system-level ESD protection
        From MSP430 datasheet:
            System-level ESD protection must be applied in compliance with the device-level ESD specification
            to prevent electrical overstress or disturbing of data or code memory. See MSP430 System-Level
            ESD Considerations for more information.
            
            Search for document titled: "MSP430 System-Level ESD Considerations"
    
    - Improve current sense resistor
        - Use low-tempco resistor
        - Change value to .2Î© or .1Î© (depending on current range)




- Image pipeline todo

    - Speed up pipeline, especially Defringe and FFCC (illuminant estimation) stages
        - Currently the whole pipeline can take ~200ms
    
    - Train FFCC (illuminant estimation) with more data and better data
    
    - Improve highlight reconstruction
        - In some cases HR makes some regions worse than if it didnâ€™t kick in at all
        - Highlights in the sky can be particularly bad -- it replaces large regions with blocks of white. 
    
    - Re-calculate color correction matrices
        - Use real color checker
        - Use a spectrometer to measure color checker squares
        - Remember that our current CCMs are calculated by averaging the identity matrix with the calculated CCM
            - We did this because it improves the output (at least when using our laser-jet printout of the colorchecker)
        
        - We should have more than 2 CCMs, and interpolate between the 2 that are the closest match
          to a illuminant (as determined by the illuminant estimation algorithm)
    
    - Implement auto exposure / exposure correction in image pipeline
        - Determine the distribution of pixel brightness, and apply some function to spread out the
          brightness distribution across the entire range
        - See:
            https://twitter.com/CSProfKGD/status/1374463703345590272
            https://github.com/mahmoudnafifi/Exposure_Correction
    
    - Correct fixed-pattern noise
        http://www.moria.de/tech/image-sensors/preparation/
        - Saved as "ImageSensors-NoiseFiltering.webarchive"
        - If you set inttime=0, fixed pattern noise seems to be maximized
    
    - Implement dead pixel correction
    
    âˆš Implement more sophisticated white balance for Defringe filter
        - To operate correctly, the raw data input into the Defringe filter needs to be white-balanced.
        - Currently, we're just white balancing using hard-coded constants, but that probably doesn't
          work well with all illuminants.
    
    âˆš Implement auto white balance (AWB)
        - Apply as very first stage (before defringing and debayering)
            - Defringe needs white-balanced image, so it makes sense to apply WB before defringing
