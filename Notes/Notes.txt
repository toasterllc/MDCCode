- Business

    - Order mass quantity
        - Small signal mosfets
            https://www.newark.com/torex/xp231p02013r-g/mosfet-p-ch-0-2a-30v-sot-323-3a/dp/91AH9291?st=mosfet
                Vt_max = 1.2 V
                Idss = 10 µA
                $0.024 @ 500
                $0.024 @ 1000
        - Lens holder (if we end up needed them)
        - Battery
        - Battery header
        - Battery housing (goes into header/receptacle)
            - Only if battery supplier can't attach proper connector to battery
        √ TPS62A01DRLR (350x) from ti.com
            √ Waiting for tax exemption to be accepted
        √ USB-C receptacle
    

- Rev7 Todo
    
    - Clean up SDController to handle 3V3 initialization
    
    - Remove MSP430<->STM32 level shifter (U15) and connect MSP_TEST / MSP_RST_ directly to STM32
        - Connect VDDSDMMC to VDD_B_3V3_STM
        - Connect MSP_TEST / MSP_RST_ to VDDSDMMC-powered pins
        - Switch capacitor on MSP_RST_ to the recommended one
    
    - Consider removing MSP430<->ICE40 level shifter (U16) and use open-drain comms
        - We only need open-drain comms on the data line, clock will always be push-pull driven by MSP430
        - Considerations:
            - Can ICE40 IOs handle being driven at 3.3V?
            - What pullup resistor value should we use?
            - Power consumption?
    
    - How do we handle SD initialization?
        - Options:
            - Option 1: Require LVS SD cards and init with 1.8V
                - If all the high-endurance cards support LVS, this seems like a good option because:
                    - Less complexity, fewer parts
                        - No need for 2 extra ICE40 IOs that control pullup voltage
                        - No need for pull-up voltage transistors
                - DDR50 may let us loosen timing constraints, since the frequency is half, and the output SB_IO is responsible for outputting
            - Option 2: Allow non-LVS cards and init with 2.8V
                - Option 2A: use an open-drain solution to be able to output 2.8V.
                X Option 2B: raise 1.8V to a higher voltage
                    X That won't work because:
                        - SD.Vih_min_3V3 = 0.625*VDD = 1.75
                        - SD.Vih_max_1V8 = 2.0
                        - ICE40.Voh_min = VCCIO–0.4
                        - Because SD.Vih_max_1V8=2, ICE40.VCCIO can't be greater than 2V. Therefore if ICE40.VCCIO=2, ICE40.Voh_min = VCCIO–0.4 = 2-.4 = 1.6
                            - But SD.Vih_min_3V3=1.75 > ICE40.Voh_min=1.6. In other words, SD requires >=1.75V to register as a '1',
                              but ICE40 may only be able to output 1.6V.
    
    - If ICE40 is going to interface directly with SD at 2.8V, can ICE40 interface directly with MSP?
    
    - Move parts (resistors, capacitors) further away front mount points on front of board
        - We want more safety margin near mount points
    
    - Update mounting hole size based on enclosure hole size
    
    - Figure out which parts are breaking when exposed to sunlight and figure out a solution
        - Streaming images breaks in direct sunlight
    
    - Layout: Make placing board into enclosure easier
        - Enclosure's bottom board mount needed to be snipped to give enough clearance
          to allow USB-C connector to go into hole
        
        - Enclosure's right backplate mount needed to be snipped to give enough clearance
            - Cut notch in board for clearance around right backplate mount?
            - Move backplate mounting points so that a notch can be cut?
    
    - Layout: battery voltage divider: move resistors R7 and R9 closer together
    
    - Layout: fix DRC errors
    
    - Add green LED to front
    
    
    
    √ Layout: fix USB receptacle layout for A9/B4 pins -- we didn't label the polygon correctly, resulting in a 'fork'
    
    √ Layout: Fix C17 label (obscured by pads)
    
    √ Layout: Make Q2 label the same size as Q3
    
    √ Layout: Fix J4 label (obscured)
    
    √ Layout: Fix R1/J1 labels (they're swapped)
    
    √ Layout: Remove cream from TagConnect footprint
    
    √ Swap ICE_STM_SPI nets so that ICERAMWrite can use QSPI to program, while ICEFlashWrite bitbangs
        - This seems like a good idea because we'll do ICERAMWrite anytime we run MDCStudio, but ICEFlashWrite only
          when flashing (which should happen rarely). Makes sense to have ICERAMWrite faster than ICEFlashWrite right?
            - Currently ICERAMWrite takes .5s when optimized with -Os
    
    √ Stop using VDD_USB as a signal; use TPS2116DRLR's ST signal instead, pulled to VDD_USB via a 10k resistor
        - Necessary because U12 appears to backfeed voltage to its enable pin, causing VDD_USB=2.5V.
            - Therefore its enable pin needs to be strongly driven (at least strongly driven low, weakly pulled high appears to work fine...)
        - 2 instances of using VDD_USB as a signal: U3, U12
    
    
    √ Battery voltage divider: change resistor values to take advantage of full ADC dynamic range
        - Currently our voltage divider ratio = 1/4 so the dynamic range = (4.2/4)/1.8 = 58% of full ADC range.
        - Switch the resistors of the voltage divider:
            - Option 1: 200k / 300k
                    - Voltage divider ratio = 1/2.5
                    - Dynamic range = (4.2/2.5)/1.8 = 93% of full ADC range.
            - Option 2: 100k / 147k (147k = 100k + 47k in series)
                - Voltage divider ratio = 1/2.47
                - Dynamic range = (4.2/2.47)/1.8 = 94% of full ADC range
            - Conclusion: use Option 1 because it's simplest
                - Just change R9 to be 200k
    
    
    √ Drive U5 (VDD_BAT voltage buffer) from an STM GPIO instead constantly while connected to USB
        - Necessary because the ADC voltage divider breaks MCP73831T's battery detection logic because
          its impedance is too low (MCP73831T requires an impedance of >7MΩ).
          - So instead, we'll disable the voltage divider except when a battery is detected
        
        - Drive from STM PA11/C15 pin
            - Need to use this pin because it can output 3.3V (by virtue of being supplied by VDDUSB)
              to meet the 74LVC1G98 Vih (2.74V when powered by 4.5V)


- Software / Firmware Todo
    
    - MSPApp: while running on battery power with CurrentRanger monitoring, after some time the current
      consumption jumped from ~8µA to ~150µA, apparently not due to motion. Was this due to RTC timer
      waking us up? If so, why didn't we go back to sleep into LPM3.5?
    
    - MSPApp: store oldest 3 aborts, and newest 3 aborts (currently we only store the oldest 3 aborts)
    
    - MDCStudio: add inspector sidebar
    
    - MSPApp: Improve exposure/gain algs
    
    - MSPApp: Optimize battery usage
        - Measure current during with various rails enabled and make sure it's what we expect
        - Currently we keep VDD_B on all the time!
    
    - Make sure that IMG i2c lines are 0V while IMG power is off
        - On Rev4, ImgI2CMaster.v writes clkOut<=1 in its Idle state, so it's being driven when IMG is powered off
    
    - Patch icepack to specify frequency=high in bitstream
        - Doesn't look like there's a way to specify that in the command line options
    
    - Replace uses of RefCounted with just std::shared_ptr with a custom deleter?
      For example, there's no need to make syscalls to retain/release an io_service_t,
      when we can just use regular memory management right?
    
    - MDCStudio/STMApp: Implement battery voltage monitoring
    
    - ImagePipeline: improve perf so that we process each thumbnail in realtime to avoid slowing image loading more than the data transfer speed
        - Ie, make sure the bottleneck remains the data transfer
            - We transfer data at 42525582 bytes/sec -> /373760 == 113.778 thumbnails/sec -> 1/113.778 == 8.789 ms/thumbnail
            - Therefore ImagePipeline needs to process every image in less than 8.789ms
            - Currently ImagePipeline takes 9-12ms per thumbnail
        
        - ImagePipeline bottlenecks appear to be:
            - FFCC (takes 9.8 ms / thumbnail)
            - LMMSE (1.2 ms / thumbnail)
            - Remainder of ImagePipeline (2 ms / thumbnail)
            - Checksum validation (0.429687 ms / thumbnail)
    
    - ImagePipeline: FFCC:
        - Create new training set
            - Use color checker with known colors
                - We could either:
                    - Measure the colors ourself, or
                    - Use a colorchecker with guaranteed colors

            - Capture lots of different lighting conditions

            - Capture images with the color checker illuminated by the primary illuminant (ie not in a shadow)

            - Black-out color checker in images

            - Ensure there aren't common elements in each image (eg Sue holding the color checker)
    
    - ImagePipeline: Improve highlight reconstruction
        - In some cases HR makes some regions worse than if it didn’t kick in at all
        - Highlights in the sky can be particularly bad -- it replaces large regions with blocks of white. 
    
    - ImagePipeline: Re-calculate color correction matrices
        - Use real color checker
        - Use a spectrometer to measure color checker squares
        - Remember that our current CCMs are calculated by averaging the identity matrix with the calculated CCM
            - We did this because it improves the output (at least when using our laser-jet printout of the colorchecker)
    
        - We should have more than 2 CCMs, and interpolate between the 2 that are the closest match
          to a illuminant (as determined by the illuminant estimation algorithm)
    
    - ImagePipeline: Implement auto exposure / exposure correction in image pipeline
        - Determine the distribution of pixel brightness, and apply some function to spread out the
          brightness distribution across the entire range
        - See:
            https://twitter.com/CSProfKGD/status/1374463703345590272
            https://github.com/mahmoudnafifi/Exposure_Correction
    
    - ImagePipeline: Correct fixed-pattern noise
        http://www.moria.de/tech/image-sensors/preparation/
        - Saved as "ImageSensors-NoiseFiltering.webarchive"
        - If you set inttime=0, fixed pattern noise seems to be maximized
    
    - ImagePipeline: Implement dead pixel correction
    
    - MDCStudio: ImageGridView: thumbnail resize
        - Use LayerScrollView -magnifyIncrease: / -magnifyDecrease: interface
        - Add slider somewhere?
    
    - MDCStudio: ImageGridView: allow arrow keys to extend the current selection when holding shift/command
        - We need sophisticated handling similar to the Finder, but we should be able to do better
    
    - MDCStudio: image rotation
        - from grid view
        - from image view
    
    - MDCStudio: ImageGridView: allow enter key to open image
    
    - MDCStudio: ImageGridView: zoom animation when entering image view
    
    - MDCStudio: image exporting
    
    - MDCStudio: image drag/drop
        - to other apps
        - to existing library
        - to new library
    
    - MDCStudio: deleting images
        - show per-device trash can when images are deleted
    
    - MDCStudio: implement inspector
    
    - STMApp: occasionally aborts in _SDInit -> USBSendStatus() because the endpoint isn't ready
        - Haven't been able to determine cause yet
    
    - STMApp: reconsider whether we should be using Task::Stop() to abort tasks that are in progress.
      for example, a task might be in the middle of executing SDCard::Disable(), which isn't designed to be aborted half way through
    
    - MSPApp: make sure SysTick (WDT) doesn't wake us from LPM3.5
    
    - Test _State.img.ringBuf/_State.img.ringBuf2 resiliency to power loss
    
    - STMApp: enumeration failed in this scenario: MDC plugged in -> comp sleep -> comp wake -> "invalid endpoint 0x81"
    
    - Task.h: debug feature: stack traces
    
    - MSPApp: can we use the 'restart' facility of reset_register to speed up integration time changes?
        - 'restart' triggers a bad frame, so experiment with the 'restart_bad' and 'mask_bad' flags too
    
    - Fix bug: Without STLink connected, sometimes STApp crashes when plugging in
        - One cause is because Img::Sensor::Init() failed, because of an IMG I2C error
            - Might be because we're not waiting long enough after turning on the power rails to do I2C comms
                - "#warning TODO: measure how long it takes for IMG rails to rise"
