Learnings

* To improve performance, try changing state machines from case(BinaryCodedStateRegister), to if(OneHotCodedShiftRegister[N]):
    
    From:
    
        case (state)
        0: ...
        1: ...
        2: ...
        endcase
    
    To:
    
        state <= state>>1;
        if (state[0]) begin
        end
        
        if (state[1]) begin
        end


* To adjust the phase of a clock supplied to an external chip, delay the clock signal using this Delay module (see Delay.v). This instantiates a SB_LUT4 directly, instead of using combinational Verilog logic, because yosys/icecube2 typically optimizes combinational logic away.

    module Delay #(
        parameter Count = 1
    )(
        input wire in,
        output wire out
    );
        wire[Count:0] bits;
        assign bits[0] = in;
        assign out = bits[Count];
        genvar i;
        for (i=0; i<Count; i=i+1) begin
            SB_LUT4 #(
                .LUT_INIT(16'bxxxx_xxxx_xxxx_xx10)
            ) SB_LUT4(
                .I3(1'b0),
                .I2(1'b0),
                .I1(1'b0),
                .I0(bits[i]),
                .O(bits[i+1])
            );
        end
    endmodule



* Use BankFifo instead of AFIFO if possible -- better performance, smaller design. Only applies if it's OK if data is sent/received in 2^N chunks, rather than word-by-word.

* ice40 RAM is invalid during the first X Âµs of startup! (This almost certainly gave us inexplicable failures in the past.)

* icecube2 ignores register initialization and doesn't assume registers start cleared, which can completely break logic. Still haven't figured out a way around this...

* Run nextpnr many times with a randomized seed, to get an average/median value for the max frequency. The frequency from a single run isn't reliable. (For example, if you just add a comment to a file, the max frequency can change drastically.)

* I don't use resets at all since FPGA registers are guaranteed to be cleared on startup. Perhaps my thinking will change in the future, but this makes designs faster, smaller, and simpler.
