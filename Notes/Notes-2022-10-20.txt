- Business

    - Order mass quantity
        - Lens holder (if we end up needed them)
        - USB-C receptacle
        - Battery
        - Battery header
        - Battery housing (goes into header/receptacle)
            - Only if battery supplier can't attach proper connector to battery
        √ TPS62A01DRLR (350x) from ti.com
            √ Waiting for tax exemption to be accepted
    

- Board Rev7 Todo
    - Drive U5 (VDD_BAT voltage buffer) from an STM GPIO instead constantly while connected to USB
        - Necessary because the ADC voltage divider breaks MCP73831T's battery detection logic because
          its impedance is too low (MCP73831T requires an impedance of >7MΩ).
          - So instead, we'll disable the voltage divider except when a battery is detected
        
        - Drive from STM PA11/C15 pin
            - Need to use this pin because it can output 3.3V (by virtue of being supplied by VDDUSB)
              to meet the 74LVC1G98 Vih (2.74V when powered by 4.5V)
    
    - Battery voltage divider: change resistor values to take advantage of full ADC dynamic range
        - Currently our voltage divider ratio = 1/4 so the dynamic range = (4.2/4)/1.8 = 58% of full ADC range.
        - Switch the resistors of the voltage divider:
            - Option 1: 200k / 300k
                    - Voltage divider ratio = 1/2.5
                    - Dynamic range = (4.2/2.5)/1.8 = 93% of full ADC range.
            - Option 2: 100k / 147k (147k = 100k + 47k in series)
                - Voltage divider ratio = 1/2.47
                - Dynamic range = (4.2/2.47)/1.8 = 94% of full ADC range
            - Conclusion: use option 1 because it's simplest
                - Just change R9 to be 200k
    
    - Battery voltage divider: move resistors R7 and R9 closer together
    
    - Stop using VDD_USB as a signal; use TPS2116DRLR's ST signal instead, pulled to VDD_USB via a 10k resistor
        - Necessary because U12 appears to backfeed voltage to its enable pin, causing VDD_USB=2.5V.
            - Therefore its enable pin needs to be strongly driven (at least strongly driven low, weakly pulled high appears to work fine...)
        - 3 instances of using VDD_USB as a signal: U3, U5, U12
    
    - Fix USB receptacle layout for A9/B4 pins -- we didn't label the polygon correctly, resulting in a 'fork'
    
    - Make placing board into enclosure easier
        - Enclosure's bottom board mount needed to be snipped to give enough clearance
          to allow USB-C connector to go into hole
        - Cut notch in board?
            - May need to move backplate mounting points so that a notch can be cut
    
    - Remove cream from TagConnect footprint
    
    - Fix R1/J1 labels (they're swapped)
    
    - Fix J4 label (obscured)
    
    - Make Q2 label the same size as Q3
    
    - Fix C17 label (obscured by pads)
    
    - Consider swapping ICE_STM_SPI nets so that ICERAMWrite can use QSPI to program, while ICEFlashWrite bitbangs
        - This seems like a good idea because we'll do ICERAMWrite anytime we run MDCStudio, but ICEFlashWrite only
          when flashing (which should happen rarely). Makes sense to have ICERAMWrite faster than ICEFlashWrite right?
            - Currently ICERAMWrite takes .5s when optimized with -Os

√ Misc
    
    - Order Rev6 prototype stuff
        √ Board
        
        √ Enclosure
        
        √ Stencils
        
        √ Reball stencils
        
        √ Mouser
            - RB168MM substitute (1x)
                - PMEG60T10ELR
            
            - PMPB10UPX substitute (3x)
                - PMPB13UP
            
            - DT1446-04V-7 substitute (1x)
                - D5V0F4U6V-7
            
            - Additional motion sensor
            
            - More ICE40s
                - It looks like Mouser will have ICE40HX8K-BG121 in stock in October 2022
        
        √ DigiKey
            - Additional image sensor
                https://www.digikey.com/en/products/detail/onsemi/AR0330CS1C12SPKA0-CR/5321549?s=N4IgTCBcDaIIICUAMBmFSDCBlAjBnYWACgNJxIC0GCIAugL5A
            
            - Battery header
                - JST: SM02B-SRSS-TB
                - Adam Tech 1SH-A-02-TR-SMT
            
            - Battery wiring socket:
                - Option 1: order housing and contacts separately
                    - Contact housing (goes into receptacle)
                        - JST: SHR-02V-S
                        - Adam Tech: 1CH-A-02
                    
                    - Contacts (to attach to battery wires and insert into housing)
                        - JST: SSH-003T-P0.2-H
                        - Adam Tech: 1CTA-R
                
                - Option 2: order pre-made housing+contacts+wiring
                    - Uses socket: JST 02SR-3S, which is compatible with our header (SM02B-SRSS-TB)
                    - A02SR02SR30K51A
                        - https://www.digikey.com/en/products/detail/jst-sales-america-inc/A02SR02SR30K51A/6009373
            
            X Solder balls
                - STM32 pitch is .65mm, so we should use .65/2 size balls:
                    https://www.digikey.com/en/products/detail/chip-quik-inc/SMD2024-25000/9558182
                X Nevermind, we're going to try the solder-paste reball method
        
        √ LCSC
            - USB-C receptacle
                - https://www.lcsc.com/product-detail/USB-Connectors_Korean-Hroparts-Elec-TYPE-C-31-M-08A_C2848616.html
        
        √ Amazon
            - Chisel solder tip (to help with desoldering BGAs)
                https://www.amazon.com/Pace-1131-0055-P1-AccuDrive-Solder-Chisel/dp/B07F1XPYSS
            
            - Battery
                https://www.amazon.com/1300mAh-103040-Rechargeable-Replacement-Electronic/dp/B09YQ2WJ75
            
            - Silicone mat (for reballing)
                http://amzn.to/2jfAiKp
        
        √ TagConnect cable (TC2030-IDC-NL) and grips
            https://www.tag-connect.com/product/tc2030-idc-nl
            https://www.tag-connect.com/product/grip-6-3-pack
        
        √ Lens holder
        
        X Jig to hold stencils (for both BGA but also for solder paste)
            X For now we're going to try using a silicone mat with a cutout for chips
        
        X PCB holder
            - https://www.adafruit.com/product/3791
            X Maybe later




- Rev6 Board Done
    
    √ Enclosure: verify that PCB holes are positioned correctly
    
    √ Enclosure: add cutout for USB port
        - Size the hole for the receptacle, not the plug, because the receptacle sticks off the board and needs to peek through the hole a bit!
    
    √ Enclosure: confirm lens extrusion depth
    
    √ PCB: make cutout for battery wire
    
    √ PCB: round corners if needed to match enclosure
    
    √ Enclosure: add small gap between board edges and enclosure
    
    √ Enclosure: adjust backplate radius to look better
    
    √ Enclosure: make backplate hole a semicircle
    
    X Layout: Add soldermask markings for STM32 header pins, if we keep the header (since we want to make backside thinner)
    
    X Layout: We should be able to make the board smaller by rotating the SD card holder 90 degrees, so that the SD
      card sticks out the side of the board
    
    √ Layout: Add soldermask markings for VDD / GND battery terminal leads
    
    √ Make new TagConnect part that doesn't have the holes on the bottom
    
    √ Check/correct SD trace lengths
    
    √ Check/correct RAM trace lengths
    
    √ Check/correct IMG trace lengths
    
    √ Verify that the new ICE40 pin assignment meets our timing (since we moved the pins since Rev5 to
      account miswiring the flash chip)
          √ Need to update Pins.pcf to do this testing
    
    √ Replace STM32 header with 6-pin TagConnect
    
    √ Replace battery connector with a smaller version
    
    √ Move battery connector to the front of the board
    
    √ Replace lens holder with the 18mm version
    
    √ Layout: move USB-C connector to the front of the board so the battery can sit flush with the back
    
    X Fix: USB C connector mount point collides with lens holder plastic (see lens holder's keepout region)
        - Not an issue in practice
    
    √ Replace U8 with a reliable 2.8V buck
        - U8: voltage selection is sporadic. It seems the 'R2D converter' can fail to choose the right voltage
          in our system because of either: slow rise of VDD_B (due to U1 slow start), or because when
          power-cycling the device, it never actually turns off because VDD_B never drains
              - Adding a voltage divider (56k,20k) to the enable pins seems to fix it
                  - Rationale: Ven = 3.8*(20/(56+20)) = 1V -> VDD_B needs to reach 3.8V before U8 turns on,
                    presumably because the added delay allows the R2D converter to function correctly
                
                  X Nevermind, it's broken again after soldering the image sensor + motion sensor (now it's 3V instead of 2.8V)
        
        - Good options:
            - DIODESINC AP3429AKTTR-G1
                - Stock: none
            - TI TLV62568A-DRL
                - Stock:
                    - ti.com
    
    √ Make STM nets consistently named 'STM', not ST; eg 'ICE_ST_FLASH_EN' needs renaming

    X We should be able to make the board smaller by removing the footprint for the motion sensor, and just
      using through-hole wires to connect to it. The motion sensor will likely need to be raised up in the
      final product, since the lens is longer than the motion sensor, therefore we'll need wires to connect
      to the board anyway.
          - Nevermind, we're planning to have motion sensor be mounted to the board
    
    √ Have STM control the VDD_B_X_EN rails directly, to clean up MSP's host-mode logic
        - MSP would control the VDD_B_X_EN rails with a weak pullup/pulldown. When STM is powered, it would control the rails with strong push/pull.
        - Rationale: we have a complicated host mode based on conflicting facts:
            1. MSP needs to be running to keep track of time,
            2. MSP rails need to be controlled via SBW/JTAG
            3. MSP rails are reset when connecting/disconnecting SBW/JTAG
        - To validate this idea, make sure MSP430 can pull up a net while connected to a high-Z STM GPIO
            √ We know it can because it's currently able to pullup the HOST_MODE_ net
                - Takes 1.74µs for MSP to pullup HOST_MODE_ net to 90% of its VDD (3.3V)

    √ Combine rails since they're always on at the same time:
        - VDD_B_1V8_IMG & VDD_B_1V8_SD
        - VDD_B_2V8_IMG & VDD_B_2V8_SD
    
    √ Consider adding a pull-down to VDD_B_EN to ensure the input isn't floating when MSP430 isn't powered
      (eg when it crashes and restarts, or when it hasn't been programmed)
    
    √ U3: needs to be powered by VDD_A, not VDD_A_3V3, because the voltage on Q1's Vgate needs to reach its
      Vsource when Q1 is supposed to be off. But if U3 is powered by VDD_A_3V3, the max voltage that U3 can
      output is 3.3V, which is less than VDD_A. As currently implemented, Q1 can never be fully turned off.
    
    √ Bug: MSP430 browns-out when asserting VDD_B_EN
        - Solution: make R4 a higher value to slow Q1 turn-on and decrease inrush current
        - 100Ω: 1.21V droop
        - 1kΩ: .77V droop
        - 10kΩ: .074V droop
            - 10k seems to work well
        - We should use the same resistor value for Q4 right?
            X Nevermind, Q4 no longer exists
    
    √ Bug: U16 level shifter that controls MSP_TEST / MSP_RST_ causes MSP_RST_ to be driven low when
      connecting device to USB power. It appears this is because the STM32 side, MSP_RST_X_, is
      floating before STM32 explicitly configures the GPIO, which the level shifter interprets as a
      low value, and drives MSP_RST_ low, causing MSP430 to be reset until STM32 drives MSP_RST_X_ high.
      This appears to happen despite MSP430's pull-up on its RST pin.
      
      √ Solution: connect U16.OE to a STM32 GPIO (instead of VDD_B_1V8_STM), perhaps called 'MSP_SBW_EN',
        and include a pull-down resistor. That way, U16 outputs will be disabled until STM32 explicitly
        wants to talk to MSP430 (by asserting MSP_SBW_EN), and so MSP_RST_ won't be affected until then.
    
    √ Add a open-drain signal from STM -> MSP, which MSP observes to prevent itself from running when STM32 asserts
        √ Done: added MSP_EN signal
        - MSP should use its internal pullup, and STM should drive to ground
    
    √ Bug: BAT_CHRG_LVL voltage divider resistance is too high for STM32 ADC input resistance
        - STM32 datasheet says maximum R_AIN is 50kΩ
        √ Fixed: added a capacitor at the ADC input to act as low-impedance charge storage
    
    √ Bug: BAT_CHRG_LVL_EN_ is subjecting STM32 to the battery voltage when STM32 is off,
      which is > the absolute maximum input voltage on FT pins of VDD+4.0
        √ Fixed: replaced transistor with 74LVC1G98GW, acting as a buffer
    
    √ Rev5 bug: ICE40.K9 needs to be connected to ICE40FLASH.DI so that ICE40 can send read commands to flash
        - Constraints:
            - STM32.D0 = ICE40FLASH.DO = ICE40.SI
            - STM32.DX = ICE40FLASH.DI = ICE40.SO
        
        - Regimes:
            - STM32 programs ICE40RAM
                - STM32.D0 = ICE40.SI
            - STM32 programs ICE40FLASH
                - ICE40FLASH.DI = STM32.DX1
                - ICE40FLASH.DO = STM32.DX2
            - ICE40 boot
                - ICE40.SI = ICE40FLASH.DO
                - ICE40.SO = ICE40FLASH.DI
        
        - Therefore:
            - ICE40.SI = ICE40FLASH.DO = STM32.DX2 = STM32.D0
            - ICE40.SO = ICE40FLASH.DI = STM32.DX1 = STM32.D6
    
    √ Why is one of the ICE40 LEDs off?
        - LED is bad
    
    √ U14 pin 1 doesn't seem to be connected to VDD_A_3V3. Only explanation seems to be that there's an
      internal board crack, because VDD_A_3V3 has the correct voltage elsewhere on the board.
        - The STM32 previously enumerated via USB, so this used to work.
        √ Solution: don't rapidly change the temp of the board eg by adding flux or rinsing in alcohol!


- Software / Firmware Todo
    
    - MSPApp: while running on battery power with CurrentRanger monitoring, after some time the current
      consumption jumped from ~8µA to ~150µA, apparently not due to motion. Was this due to RTC timer
      waking us up? If so, why didn't we go back to sleep into LPM3.5?
    
    - MSPApp: store oldest 3 aborts, and newest 3 aborts (currently we only store the oldest 3 aborts)
    
    - MDCStudio: add inspector sidebar
    
    - MSPApp: Improve exposure/gain algs
    
    - MSPApp: Optimize battery usage
        - Measure current during with various rails enabled and make sure it's what we expect
        - Currently we keep VDD_B on all the time!
    
    - Make sure that IMG i2c lines are 0V while IMG power is off
        - On Rev4, ImgI2CMaster.v writes clkOut<=1 in its Idle state, so it's being driven when IMG is powered off
    
    - Patch icepack to specify frequency=high in bitstream
        - Doesn't look like there's a way to specify that in the command line options
    
    - Replace uses of RefCounted with just std::shared_ptr with a custom deleter?
      For example, there's no need to make syscalls to retain/release an io_service_t,
      when we can just use regular memory management right?
    
    - MDCStudio/STMApp: Implement battery voltage monitoring
    
    - ImagePipeline: improve perf so that we process each thumbnail in realtime to avoid slowing image loading more than the data transfer speed
        - Ie, make sure the bottleneck remains the data transfer
            - We transfer data at 42525582 bytes/sec -> /373760 == 113.778 thumbnails/sec -> 1/113.778 == 8.789 ms/thumbnail
            - Therefore ImagePipeline needs to process every image in less than 8.789ms
            - Currently ImagePipeline takes 9-12ms per thumbnail
        
        - ImagePipeline bottlenecks appear to be:
            - FFCC (takes 9.8 ms / thumbnail)
            - LMMSE (1.2 ms / thumbnail)
            - Remainder of ImagePipeline (2 ms / thumbnail)
            - Checksum validation (0.429687 ms / thumbnail)
    
    - ImagePipeline: FFCC:
        - Create new training set
            - Use color checker with known colors
                - We could either:
                    - Measure the colors ourself, or
                    - Use a colorchecker with guaranteed colors

            - Capture lots of different lighting conditions

            - Capture images with the color checker illuminated by the primary illuminant (ie not in a shadow)

            - Black-out color checker in images

            - Ensure there aren't common elements in each image (eg Sue holding the color checker)
    
    - ImagePipeline: Improve highlight reconstruction
        - In some cases HR makes some regions worse than if it didn’t kick in at all
        - Highlights in the sky can be particularly bad -- it replaces large regions with blocks of white. 
    
    - ImagePipeline: Re-calculate color correction matrices
        - Use real color checker
        - Use a spectrometer to measure color checker squares
        - Remember that our current CCMs are calculated by averaging the identity matrix with the calculated CCM
            - We did this because it improves the output (at least when using our laser-jet printout of the colorchecker)
    
        - We should have more than 2 CCMs, and interpolate between the 2 that are the closest match
          to a illuminant (as determined by the illuminant estimation algorithm)
    
    - ImagePipeline: Implement auto exposure / exposure correction in image pipeline
        - Determine the distribution of pixel brightness, and apply some function to spread out the
          brightness distribution across the entire range
        - See:
            https://twitter.com/CSProfKGD/status/1374463703345590272
            https://github.com/mahmoudnafifi/Exposure_Correction
    
    - ImagePipeline: Correct fixed-pattern noise
        http://www.moria.de/tech/image-sensors/preparation/
        - Saved as "ImageSensors-NoiseFiltering.webarchive"
        - If you set inttime=0, fixed pattern noise seems to be maximized
    
    - ImagePipeline: Implement dead pixel correction
    
    - MDCStudio: ImageGridView: thumbnail resize
        - Use LayerScrollView -magnifyIncrease: / -magnifyDecrease: interface
        - Add slider somewhere?
    
    - MDCStudio: ImageGridView: allow arrow keys to extend the current selection when holding shift/command
        - We need sophisticated handling similar to the Finder, but we should be able to do better
    
    - MDCStudio: image rotation
        - from grid view
        - from image view
    
    - MDCStudio: ImageGridView: allow enter key to open image
    
    - MDCStudio: ImageGridView: zoom animation when entering image view
    
    - MDCStudio: image exporting
    
    - MDCStudio: image drag/drop
        - to other apps
        - to existing library
        - to new library
    
    - MDCStudio: deleting images
        - show per-device trash can when images are deleted
    
    - MDCStudio: implement inspector
    
    - STMApp: occasionally aborts in _SDInit -> USBSendStatus() because the endpoint isn't ready
        - Haven't been able to determine cause yet
    
    - STMApp: reconsider whether we should be using Task::Stop() to abort tasks that are in progress.
      for example, a task might be in the middle of executing SDCard::Disable(), which isn't designed to be aborted half way through
    
    - MSPApp: make sure SysTick (WDT) doesn't wake us from LPM3.5
    
    - Test _State.img.ringBuf/_State.img.ringBuf2 resiliency to power loss
    
    - STMApp: enumeration failed in this scenario: MDC plugged in -> comp sleep -> comp wake -> "invalid endpoint 0x81"
    
    - Task.h: debug feature: stack traces
    
    - MSPApp: can we use the 'restart' facility of reset_register to speed up integration time changes?
        - 'restart' triggers a bad frame, so experiment with the 'restart_bad' and 'mask_bad' flags too
    
    - Fix bug: Without STLink connected, sometimes STApp crashes when plugging in
        - One cause is because Img::Sensor::Init() failed, because of an IMG I2C error
            - Might be because we're not waiting long enough after turning on the power rails to do I2C comms
                - "#warning TODO: measure how long it takes for IMG rails to rise"
