#pragma once
#include <optional>
#include <atomic>
#include <algorithm>
#include "Img.h"
#include "SD.h"
#include "ImgSD.h"
#include "Time.h"
#include "Toastbox/Util.h"

namespace MSP {

// BatteryLevelMv: battery voltage in millivolts
using BatteryLevelMv = uint16_t;
constexpr BatteryLevelMv BatteryLevelMvInvalid = 0;
constexpr BatteryLevelMv BatteryLevelMvMin     = 3000;

// BatteryLevel: battery voltage, linearized between [1,65535]
using BatteryLevel = uint16_t;
constexpr BatteryLevel BatteryLevelInvalid = 0x0000;
constexpr BatteryLevel BatteryLevelMin     = 0x0001;
constexpr BatteryLevel BatteryLevelMax     = 0xFFFF;

// BatteryLevelLinearize(): converts a voltage (in millivolts) into a linear
// range between BatteryLevelMin and BatteryLevelMax
inline BatteryLevel BatteryLevelLinearize(BatteryLevelMv mv) {
    struct Entry {
        BatteryLevelMv mv;
        BatteryLevel level;
    };
    
    // Table: generated by MDCAnalysis/BatteryLevelTableGenerate.py
    // Let f(t) = battery voltage versus time, where time is normalized
    // between [0x0, 0xFFFF].
    // This table is a piecewise-linear representation of inverse[f(t)]:
    // it accepts a voltage, and returns the 'normalized time' corresponding
    // to that voltage, which can be thought of as the battery charge level.
    // If this table models the battery correctly, the returned result should
    // progress linearly, in contrast to the battery's non-linear
    // charge/discharge curve.
    // In user-facing terms: this table should behave such that capturing N
    // photos per day should deplete the battery X% per day, regardless of
    // how charged the battery is.
    static constexpr Entry Table[] = {
        { 3000,   228 },    // y must be >= BatteryLevelMin
        { 3150,   585 },
        { 3300,  1183 },
        { 3375,  1638 },
        { 3450,  2262 },
        { 3525,  3142 },
        { 3600,  4421 },
        { 3638,  5283 },
        { 3675,  6351 },
        { 3712,  7689 },
        { 3750,  9385 },
        { 3769, 10404 },
        { 3788, 11559 },
        { 3806, 12874 },
        { 3825, 14374 },
        { 3844, 16087 },
        { 3863, 18045 },
        { 3881, 20283 },
        { 3900, 22834 },
        { 3919, 25729 },
        { 3938, 28990 },
        { 3956, 32615 },
        { 3975, 36572 },
        { 4013, 45099 },
        { 4031, 49339 },
        { 4050, 53282 },
        { 4059, 55078 },
        { 4069, 56729 },
        { 4078, 58221 },
        { 4088, 59546 },
        { 4097, 60702 },
        { 4106, 61693 },
        { 4116, 62529 },
        { 4125, 63220 },
        { 4144, 64234 },
        { 4162, 64860 },
        { 4181, 65219 },
        { 4200, 65408 },    // y must be <= BatteryLevelMax
    };
    static_assert(Table[0].mv == BatteryLevelMvMin);
    
    // If the measured voltage is less than the minimum voltage we expect, assume that we don't
    // have a battery and return BatteryLevelInvalid.
    if (mv < Table[0].mv) return BatteryLevelInvalid;
    
    auto it = std::lower_bound(std::begin(Table), std::end(Table), 0,
        [&](const Entry& entry, auto) -> bool {
            return entry.mv < mv;
        });
    
    // If the result is the first element, then we can't get the element before it
    // to perform interpolation with, so consider ourself at the minimum charge
    // level.
    if (it == std::begin(Table)) {
        return BatteryLevelMin;
    // If we couldn't find a matching element, then there's no element >= `mv`,
    // so `mv` must be greater than all of our Table entries, so consider ourself
    // at the maximum charge level.
    } else if (it == std::end(Table)) {
        return BatteryLevelMax;
    }
    
    const Entry& left = *std::prev(it);
    const Entry& right = *it;
    
    // Interpolate between `left` and `right`, where the result is normalized to u16 (or more
    // precisely, between the extremes of the y axis of `Table`.)
    const BatteryLevel level =
        left.level + (((uint32_t)(mv-left.mv) * (uint32_t)(right.level-left.level)) / (right.mv-left.mv));
    return level;
}

constexpr SD::Block SDBlockFull(SD::Block base, uint32_t idx) {
    return base - ((idx+1) * ImgSD::Full::ImageBlockCount);
}

constexpr SD::Block SDBlockThumb(SD::Block base, uint32_t idx) {
    return base - ((idx+1) * ImgSD::Thumb::ImageBlockCount);
}

// ImgRingBuf: stats to track captured images
struct [[gnu::packed]] ImgRingBuf {
    struct [[gnu::packed]] {
        Img::Id id;   // Next image id
        uint32_t idx; // Next image index
    } buf;
    bool valid;
    
    static void Set(ImgRingBuf& a, const ImgRingBuf& b) {
        a.valid = false;
        // Ensure that `valid` is reset before we modify `buf`
        std::atomic_signal_fence(std::memory_order_seq_cst);
        a.buf = b.buf;
        // Ensure that `buf` is valid before we set `valid`
        std::atomic_signal_fence(std::memory_order_seq_cst);
        a.valid = true;
    }
    
    static std::optional<int> Compare(const ImgRingBuf& a, const ImgRingBuf& b) {
        if (a.valid && b.valid) {
            if (a.buf.id > b.buf.id) return 1;
            else if (a.buf.id < b.buf.id) return -1;
            else return 0;
        
        } else if (a.valid) {
            return 1;
        
        } else if (b.valid) {
            return -1;
        }
        return std::nullopt;
    }
};

// Reset: records history of a type of reset (either abort or an unexpected reset)
struct [[gnu::packed]] Reset {
    enum class Type : uint8_t {
        Reset,
        Abort,
    };
    
    Type type;
    uint8_t count;
    
    union [[gnu::packed]] {
        struct [[gnu::packed]] {
            uint16_t reason;
        } Reset;
        
        struct [[gnu::packed]] {
            uint16_t addr;
        } Abort;
        
        uint16_t u16;
    } ctx;
    
    // We got rid of the time-tracking aspect of Reset for a few reasons:
    //   - it takes up a lot of space
    //   - we abort sometimes from the interrupt context, and we can't safely get the time there,
    //     because RTC::Tocks() calls Scheduler::Delay(), which isn't meant to be called from the
    //     interrupt context
    //   - we abort sometimes before RTC is configured, and we can't safely call RTC::Now() before
    //     it's configured, because it'll hang in Tocks() because RTCCNT never escapes 0
//    Time::Instant earliest = {};
//    Time::Instant latest   = {};
};
static_assert(!(sizeof(Reset) % 2)); // Check alignment
static_assert(sizeof(Reset) == 4); // Debug

struct [[gnu::packed]] Repeat {
    enum class Type : uint8_t {
        Never,
        Daily,
        Weekly,
        Yearly,
    };
    
    Type type;
    union [[gnu::packed]] {
        struct [[gnu::packed]] {
            uint8_t interval;
        } Daily;
        
        struct [[gnu::packed]] {
            uint8_t days;
        } Weekly;
        
        struct [[gnu::packed]] {
            uint8_t leapPhase;
        } Yearly;
    };
};
static_assert(sizeof(Repeat) == 2);

// Capture: describes the capture action when a trigger occurs
struct [[gnu::packed]] Capture {
    uint32_t delayTicks;
    uint16_t count;
    uint8_t ledFlash;
    uint8_t _pad;
};
static_assert(!(sizeof(Capture) % 2)); // Check alignment

struct [[gnu::packed]] Triggers {
    struct [[gnu::packed]] Event {
        enum class Type : uint8_t {
            TimeTrigger,
            MotionEnable,
        };
        Time::Instant time;
        Type type;
        Repeat repeat;
        uint8_t idx;
    };
    static_assert(!(sizeof(Event) % 2)); // Check alignment
    
    struct [[gnu::packed]] TimeTrigger {
        Capture capture;
    };
    static_assert(!(sizeof(TimeTrigger) % 2)); // Check alignment
    
    struct [[gnu::packed]] MotionTrigger {
        Capture capture;
        // count: the maximum number of triggers until motion is suppressed (0 == unlimited)
        uint16_t count;
        // durationTicks: duration for which motion should be enabled (0 == forever)
        Time::Ticks32 durationTicks;
        // suppressTicks: duration to suppress motion, after motion occurs (0 == no suppression)
        Time::Ticks32 suppressTicks;
    };
    static_assert(!(sizeof(MotionTrigger) % 2)); // Check alignment
    
    struct [[gnu::packed]] ButtonTrigger {
        Capture capture;
    };
    static_assert(!(sizeof(ButtonTrigger) % 2)); // Check alignment
    
    Event         event[32];
    TimeTrigger   timeTrigger[8];
    MotionTrigger motionTrigger[8];
    ButtonTrigger buttonTrigger[2];
    
    uint8_t eventCount;
    uint8_t timeTriggerCount;
    uint8_t motionTriggerCount;
    uint8_t buttonTriggerCount;
    
    // source: opaque data used by software to hold its representation of this struct
    uint8_t source[256];
};
//StaticPrint(sizeof(Triggers));


//struct [[gnu::packed]] Triggers {
//    struct [[gnu::packed]] TimeTrigger {
//        Time::Instant time = 0;
//        Repeat repeat;
//        Capture capture;
//    };
//    static_assert(!(sizeof(TimeTrigger) % 2)); // Check alignment
//    
//    struct [[gnu::packed]] MotionTrigger {
//        Time::Instant time = 0;
//        Repeat repeat;
//        Capture capture;
//        // count: the maximum number of triggers until motion is suppressed (0 == unlimited)
//        uint16_t count = 0;
//        // durationTicks: duration for which motion should be enabled (0 == forever)
//        uint32_t durationTicks = 0;
//        // suppressTicks: duration to suppress motion, after motion occurs (0 == no suppression)
//        uint32_t suppressTicks = 0;
//    };
//    static_assert(!(sizeof(MotionTrigger) % 2)); // Check alignment
//    
//    struct [[gnu::packed]] ButtonTrigger {
//        Capture capture;
//    };
//    static_assert(!(sizeof(ButtonTrigger) % 2)); // Check alignment
//    
//    TimeTrigger   timeTrigger[32];
//    MotionTrigger motionTrigger[8];
//    ButtonTrigger buttonTrigger[2];
//    
//    uint8_t timeTriggerCount   = 0;
//    uint8_t motionTriggerCount = 0;
//    uint8_t buttonTriggerCount = 0;
//    uint8_t _pad               = 0;
//    
//    // source: opaque data used by software to hold its representation of this struct
//    uint8_t source[256] = {};
//};
//StaticPrint(sizeof(Triggers));

struct [[gnu::packed]] Settings {
    Triggers triggers;
//    StaticPrint(sizeof(triggers));
    static_assert(sizeof(triggers) == 868); // Debug
};

struct [[gnu::packed]] State {
    struct [[gnu::packed]] Header {
        uint32_t magic;
        uint16_t version;
        uint16_t length;
    };
    
    Header header;
    static_assert(sizeof(header) == 8);
    
    struct [[gnu::packed]] {
        // cardId: the SD card's CID, used to determine when the SD card has been
        // changed, and therefore we need to update `imgCap` and reset `ringBufs`
        SD::CardId cardId;
        // imgCap: image capacity; the number of images that bounds the ring buffer
        uint32_t imgCap;
        // baseFull / baseThumb: the first block of the full-size and thumb image regions.
        // The SD card is broken into 2 regions (fullSize, thumbnails), to allow the host
        // to quickly read the thumbnails.
        SD::Block baseFull;
        SD::Block baseThumb;
        // ringBufs: tracks captured images on the SD card; 2 copies in case there's a
        // power failure while updating one
        ImgRingBuf imgRingBufs[2];
        bool valid;
        uint8_t _pad;
    } sd;
//    StaticPrint(sizeof(sd));
    static_assert(!(sizeof(sd) % 2)); // Check alignment
    static_assert(sizeof(sd) == 56); // Debug
    
    Settings settings;
//    StaticPrint(sizeof(settings));
    static_assert(!(sizeof(settings) % 2)); // Check alignment
    static_assert(sizeof(settings) == 868); // Debug
    
    // resets: records resets that have occurred
    Reset resets[10];
//    StaticPrint(sizeof(aborts));
    static_assert(!(sizeof(resets) % 2)); // Check alignment
    static_assert(sizeof(resets) == 40); // Debug
};
//StaticPrint(sizeof(State));
static_assert(!(sizeof(State) % 2)); // Check alignment
static_assert(sizeof(State) == 972); // Debug

constexpr State::Header StateHeader = {
    .magic   = 0xDECAFBAD,
    .version = 0,
    .length  = sizeof(State),
};

constexpr uint8_t I2CAddr = 0x55;

struct [[gnu::packed]] TimeState {
    Time::Instant start;
    Time::Instant time;
};
static_assert(!(sizeof(TimeState) % 2)); // Check alignment
static_assert(sizeof(TimeState) == 16); // Debug

struct [[gnu::packed]] TimeAdjustment {
    int32_t value;          // Current adjustment to `time`
    Time::Ticks32 counter;  // Counts ticks until `counter >= `interval`
    Time::Ticks32 interval; // Interval upon which we perform `value += delta`
    int16_t delta;          // Amount to add to `value` when `counter >= interval`
};
static_assert(!(sizeof(TimeAdjustment) % 2)); // Check alignment
static_assert(sizeof(TimeAdjustment) == 14); // Debug

enum class ChargeStatus : uint8_t {
    Invalid,
    Shutdown,
    Underway,
    Complete,
};

struct [[gnu::packed]] BatteryStatus {
    ChargeStatus chargeStatus = ChargeStatus::Invalid;
    BatteryLevelMv level = MSP::BatteryLevelMvInvalid;
};

struct [[gnu::packed]] Cmd {
    static constexpr uint8_t ArgLen = 16;
    
    enum class Op : uint8_t {
        None,
        StateRead,
        StateWrite,
        BatteryStatusGet,
        ChargeStatusSet,
        TimeGet,
        TimeSet,
        TimeAdjust,
        HostModeSet,
        VDDIMGSDSet,
    };
    
    Op op;
    uint8_t _pad;
    
    union {
        struct [[gnu::packed]] {
            uint16_t off;
        } StateRead;
        
        struct [[gnu::packed]] {
            uint16_t off;
            uint8_t data[ArgLen-sizeof(off)];
        } StateWrite;
        
        struct [[gnu::packed]] {
            ChargeStatus status;
        } ChargeStatusSet;
        
        struct [[gnu::packed]] {
            TimeState state;
        } TimeSet;
        
        struct [[gnu::packed]] {
            TimeAdjustment adjustment;
        } TimeAdjust;
        
        struct [[gnu::packed]] {
            uint8_t en;
        } HostModeSet;
        
        struct [[gnu::packed]] {
            uint8_t en;
        } VDDIMGSDSet;
        
        uint8_t _[ArgLen]; // Set size of argument
    } arg;
    static_assert(sizeof(arg) == ArgLen); // Check size
};

struct [[gnu::packed]] Resp {
    static constexpr uint8_t ArgLen = 16;
    
    uint8_t ok;
    uint8_t _pad;
    
    union {
        struct [[gnu::packed]] {
            uint8_t data[ArgLen];
        } StateRead;
        
        struct [[gnu::packed]] {
            BatteryStatus status;
        } BatteryStatusGet;
        
        struct [[gnu::packed]] {
            TimeState state;
        } TimeGet;
        
        uint8_t _[ArgLen]; // Set size of argument
    } arg;
    static_assert(sizeof(arg) == ArgLen); // Check size
};

//struct [[gnu::packed]] Triggers {
//    struct [[gnu::packed]] TimeTrigger {
//        enum class Type : uint8_t {
//            Capture,
//            MotionEnable,
//            MotionDisable,
//        };
//        
//        Type type;
//        Time::Instant time;
//        size_t idx;
//    };
//    
//    struct [[gnu::packed]] Capture {
//        
//    };
//    
//    TimeTrigger time[64];
//    Capture capture[8];
//    Motion motion[8];
//    Button button[2];
//};

struct [[gnu::packed]] DebugLogPacket {
    enum class Type : uint16_t {
        Chars = 0x8000, // High bit must be used to disambiguate against ASCII characters
        Dec16,
        Dec32,
        Dec64,
        Hex16,
        Hex32,
        Hex64,
    };
    
    union [[gnu::packed]] {
        Type type;
        uint8_t u8[2];
        uint16_t u16;
    };
};

} // namespace MSP
