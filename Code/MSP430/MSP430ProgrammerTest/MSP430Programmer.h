#include <msp430g2553.h>

using byte = uint8_t;
using word = uint16_t;

//! \brief JTAG interface on a device that supports JTAG and SBW
#define SPYBIWIREJTAG_IF    1
//! \brief Spy-Bi-Wire interface
#define SPYBIWIRE_IF        2

#define INTERFACE  SPYBIWIRE_IF

#if( INTERFACE == SPYBIWIRE_IF )
#define SPYBIWIRE_MODE 
#else
#define JSBW
#endif

#define RSTLOW_SBW   0
#define RSTLOW_JTAG  1
#define RSTHIGH_SBW  2
#define RSTHIGH_JTAG 3

#ifndef __DATAFORMATS__
#define __DATAFORMATS__
#define F_BYTE                     8
#define F_WORD                     16
#define F_ADDR                     20
#define F_LONG                     32
#endif

//! \brief Set the target's Vcc level supplied by REP430F 
//! \details data = 10*Vcc - range 2.1V to 3.6V or 0 (Vcc-OFF)  
#define VCC_LEVEL  30

//! \brief Enable FR4xx/FR2xx special handling
//! \details Comment in this line if the target is an FR4xx/FR2xx device
//#define FR4xxFR2xx

//! \brief Set start address of the main memory
#define MAIN_START_ADDRESS 0xC200

//! \brief Set length of main memory
//! \details Note that the memory length is counted in 16-bit WORDS!
#define MAIN_LENGTH 0x3E00

//! \brief Set the start address of the device RAM
#define RAM_START_ADDRESS 0x1C00

//! \brief Select the main clock frequency
//! \details Comment it out for MCLK=12MHz, if the Voltage supplied to the 
//! REP430F is low (below 2.5V).
//! That can apply when the REP430F is supplied from the target device, not 
//! from the external power supply.
#define MCLK_18MHZ
//! \brief Use Jtag Mailbox to write FRAM
//#define MailBoxWriteFram
//! \brief Activate support for Low Power Mode x.5
#define LPM5_ACTIVATED  1
//! \brief Allow use of the "magic pattern"
#define ACTIVATE_MAGIC_PATTERN  1
//! \brief Buffer size for read and write operations in words
#define WordBufferSize  50
//! \brief Maximum number of tries for the determination of the core
//! identification info
#define MAX_ENTRY_TRY  4



/****************************************************************************/
/* Define section for constants                                             */
/****************************************************************************/

// Constants for flash erasing modes
//! \brief Constant for an erase of the entire flash main memory
#define ERASE_MAIN          0xA506
//! \brief Constants for an erase of a single flash memory bank
#define ERASE_BANK          0xA504
//! \brief Constant for an erase of the selected flash memory segment
#define ERASE_SEGMENT       0xA502
//! \brief Constant for an erase of the FRAM Main memory on FR5xx/FR6xx
#define MAIN_ERASE  0x1A1A
//! \brief Constant for an erase of the FRAM Main, INFO  & IP 
//! protected memory on FR5xx/FR6xx
#define TOTAL_ERASE  0x1B1B
//! \brief Constant for an erase of the FRAM Main & INFO memory including JTAG 
//! lock signature on FR4xx
#define USER_CODE_ERASE  0x1A1A
#define STOP_DEVICE 0xA55A

//----------------------------------------------------------------------------
// Constants for the JTAG instruction register (IR) require LSB first.
// The MSB has been interchanged with LSB due to use of the same shifting
// function as used for the JTAG data register (DR) which requires MSB 
// first.
//----------------------------------------------------------------------------

// Instructions for the JTAG control signal register
//! \brief Set the JTAG control signal register
#define IR_CNTRL_SIG_16BIT         0xC8   // original value: 0x13
//! \brief Read out the JTAG control signal register
#define IR_CNTRL_SIG_CAPTURE       0x28   // original value: 0x14
//! \brief Release the CPU from JTAG control
#define IR_CNTRL_SIG_RELEASE       0xA8   // original value: 0x15

// Instructions for the JTAG fuse
//! \brief Prepare for JTAG fuse blow
#define IR_PREPARE_BLOW            0x44   // original value: 0x22
//! \brief Perform JTAG fuse blow
#define IR_EX_BLOW                 0x24   // original value: 0x24

// Instructions for the JTAG data register
//! \brief Set the MSP430 MDB to a specific 16-bit value with the next 
//! 16-bit data access 
#define IR_DATA_16BIT              0x82   // original value: 0x41
//! \brief Set the MSP430 MDB to a specific 16-bit value (RAM only)
#define IR_DATA_QUICK              0xC2   // original value: 0x43

// Instructions for the JTAG PSA mode
//! \brief Switch JTAG data register to PSA mode
#define IR_DATA_PSA                0x22   // original value: 0x44
//! \brief Shift out the PSA pattern generated by IR_DATA_PSA
#define IR_SHIFT_OUT_PSA           0x62   // original value: 0x46

// Instructions for the JTAG address register
//! \brief Set the MSP430 MAB to a specific 16-bit value
//! \details Use the 20-bit macro for 430X and 430Xv2 architectures
#define IR_ADDR_16BIT              0xC1   // original value: 0x83
//! \brief Read out the MAB data on the next 16/20-bit data access
#define IR_ADDR_CAPTURE            0x21   // original value: 0x84
//! \brief Set the MSP430 MDB with a specific 16-bit value and write
//! it to the memory address which is currently on the MAB
#define IR_DATA_TO_ADDR            0xA1   // original value: 0x85
//! \brief Bypass instruction - TDI input is shifted to TDO as an output
#define IR_BYPASS                  0xFF   // original value: 0xFF
#define IR_DATA_CAPTURE            0x42

// JTAG identification values for all existing Flash-based MSP430 devices
//! \brief JTAG identification value for 430X architecture devices
#define JTAG_ID                    0x89
//! \brief JTAG identification value for 430Xv2 architecture devices
#define JTAG_ID91                  0x91
//! \brief JTAG identification value for 430Xv2 architecture FR4XX/FR2xx devices
#define JTAG_ID98                  0x98
//! \brief JTAG identification value for 430Xv2 architecture FR59XX devices
#define JTAG_ID99                  0x99
// Additional instructions for JTAG_ID91 architectures
//! \brief Instruction to determine device's CoreIP
#define IR_COREIP_ID               0xE8   // original value: 0x17
//! \brief Instruction to determine device's DeviceID
#define IR_DEVICE_ID               0xE1   // original value: 0x87

// Instructions for the JTAG mailbox
//! \brief Request a JTAG mailbox exchange
#define IR_JMB_EXCHANGE            0x86   // original value: 0x61
//! \brief Instruction for test register in 5xx
#define IR_TEST_REG                0x54   // original value: 0x2A
//! \brief Instruction for 3 volt test register in 5xx
#define IR_TEST_3V_REG             0xF4   // original value: 0x2F

// Constants for JTAG mailbox data exchange
//! \brief JTAG mailbox constant - 
#define OUT1RDY 0x0008
//! \brief JTAG mailbox constant - 
#define IN0RDY  0x0001
//! \brief JTAG mailbox constant - 
#define JMB32B  0x0010
//! \brief JTAG mailbox constant - 
#define OUTREQ  0x0004
//! \brief JTAG mailbox constant - 
#define INREQ   0x0001
//! \brief JTAG mailbox mode 32 bit - 
#define MAIL_BOX_32BIT 0x10
//! \brief JTAG mailbox moede 16 bit - 
#define MAIL_BOX_16BIT 0x00

// Constants for runoff status
//! \brief return 0 = error
#define STATUS_ERROR     0      // false
//! \brief return 1 = no error
#define STATUS_OK        1      // true
//! \brief GetDevice returns this if the security fuse is blown
#define STATUS_FUSEBLOWN 2

//! \brief Replicator is active
#define STATUS_ACTIVE    2
//! \brief Replicator is idling
#define STATUS_IDLE      3

// dedicated addresses
//! \brief Triggers a regular reset on device release from JTAG control
#define V_RESET                    0xFFFE
//! \brief Triggers a "brown-out" reset on device release from JTAG control
#define V_BOR                      0x1B08

// Constants for VPP connection at Blow-Fuse
//! \brief Fuse blow voltage is supplied via the TDI pin
#define VPP_ON_TDI                 0
//! \brief Fuse blow voltage is supplied via the TEST pin
#define VPP_ON_TEST                 1

//! \brief Holds the value of TDO-bit
bool tdo_bit = false;
//! \brief Holds the last value of TCLK before entering a JTAG sequence
bool TCLK_saved = true;




bool TSTRead() {
    return P1IN & BIT4;
}

bool RSTRead() {
    return P1IN & BIT5;
}

void TSTWrite(bool x) {
    if (x)  P1OUT   |=  BIT4;
    else    P1OUT   &= ~BIT4;
}

void RSTWrite(bool x) {
    if (x)  P1OUT   |=  BIT5;
    else    P1OUT   &= ~BIT5;
}

void TSTDir(bool out) {
    if (out)    P1DIR   |=  BIT4;
    else        P1DIR   &= ~BIT4;
}

void RSTDir(bool out) {
    if (out)    P1DIR   |=  BIT5;
    else        P1DIR   &= ~BIT5;
}

#define TCKRead     TSTRead
#define TDIORead    RSTRead
#define TCKWrite    TSTWrite
#define TDIOWrite   RSTWrite
#define TCKDir      TSTDir
#define TDIODir     RSTDir


#define CPUFreqMHz 16
#define DelayUs(us) __delay_cycles(CPUFreqMHz*us);

void DelayMs(uint32_t ms) {
    for (volatile uint32_t i=0; i<ms; i++) {
        DelayUs(1000);
    }
}







//! \brief Delay function as a transition between SBW time slots
void nNOPS() {
    DelayUs(1);
}

//! \brief SBW macro: set TMS signal
void TMSH() {
    TDIOWrite(1);
    nNOPS();
    TCKWrite(0);
    nNOPS();
    TCKWrite(1);
}
//! \brief SBW macro: clear TMS signal
void TMSL() {
    TDIOWrite(0);
    nNOPS();
    TCKWrite(0);
    nNOPS();
    TCKWrite(1);
}
//! \brief SBW macro: clear TMS signal and immediately set it high again in
//! the SBWTCK low phase to enter the TDI slot with a high signal 
//! \details Only used to clock TCLK (=TDI for SBW) in Run-Test/IDLE mode of
//! the JTAG FSM 
void TMSLDH() {
    TDIOWrite(0);
    nNOPS();
    TCKWrite(0);
    nNOPS();
    TDIOWrite(1);
    TCKWrite(1);
}
//! \brief SBW macro: Set TDI = 1
void TDIH() {
    TDIOWrite(1);
    nNOPS();
    TCKWrite(0);
    nNOPS();
    TCKWrite(1);
}
//! \brief SBW macro: clear TDI signal
void TDIL() {
    TDIOWrite(0);
    nNOPS();
    TCKWrite(0);
    nNOPS();
    TCKWrite(1);
}
//! \brief SBW macro: TDO cycle without reading TDO
void TDOsbw() {
    TDIODir(0);
    nNOPS();
    TCKWrite(0);
    nNOPS();
    TCKWrite(1);
    TDIODir(1);
}
//! \brief SBW macro: TDO cycle with TDO read
void TDO_RD() {
    TDIODir(0);
    nNOPS();
    TCKWrite(0);
    nNOPS();
    tdo_bit = TDIORead();
    TCKWrite(1);
    TDIODir(1);
}


//  combinations of sbw-cycles (TMS, TDI, TDO)
//---------------------------------
void TMSL_TDIL(void)
{
    TMSL();
    TDIL();
    TDOsbw();
}
//---------------------------------
void TMSH_TDIL(void)
{
    TMSH();
    TDIL();
    TDOsbw();
}
//------------------------------------
void TMSL_TDIH(void)
{
    TMSL();
    TDIH();
    TDOsbw();
}
//-------------------------------------
void TMSH_TDIH(void)
{
    TMSH();
    TDIH();
    TDOsbw();
}
//------------------------------------
void TMSL_TDIH_TDOrd(void)
{
    TMSL();
    TDIH();
    TDO_RD();
}
//------------------------------------
void TMSL_TDIL_TDOrd(void)
{
    TMSL();
    TDIL();
    TDO_RD();
}
//------------------------------------
void TMSH_TDIH_TDOrd(void)
{
    TMSH();
    TDIH();
    TDO_RD();
}
//------------------------------------
void TMSH_TDIL_TDOrd(void)
{
    TMSH();
    TDIL();
    TDO_RD();
}

//----------------------------------------------------------------------------
//! \brief Set all JTAG pins to input direction - from target to REP430F
void IO_3state(void)
{
    TSTDir(0);
    RSTDir(0);
}

//----------------------------------------------------------------------------
//! \brief Set SBW pins to output direction - from REP430F to target
void configure_IO_SBW(void)
{
    TSTDir(1);
    RSTDir(1);
}

//----------------------------------------------------------------------------
//! \brief Set up I/O pins for JTAG communication
void DrvSignals(void)
{
    IO_3state();
  #if ( INTERFACE == SPYBIWIRE_IF )
    TSTWrite(0);
    RSTWrite(0);
    configure_IO_SBW();
  #else 
    JTAGOUT  = TDI | TMS | TCK | TCLK | RST;
    configure_IO_JTAG();
  #endif
}

//----------------------------------------------------------------------------
//! \brief Release I/O pins
void RlsSignals(void)
{
    IO_3state();
}

//----------------------------------------------------------------------------
//! \brief Function to set up the JTAG pins
void ConnectJTAG()
{
    // drive JTAG/TEST signals
    DrvSignals();
    DelayMs(15);             // delay 15ms
}

//----------------------------------------------------------------------------
//! \brief Function to stop the JTAG communication by releasing the JTAG signals
void StopJtag (void)
{
    // release JTAG/TEST signals
    RlsSignals();
    DelayMs(15);             // delay 15ms
}


//----------------------------------------------------------------------------
//! \brief Clear TCLK in Spy-Bi-Wire mode
//! \details enters with TCLK_saved and exits with TCLK = 0
void ClrTCLK_sbw(void)
{
    if (TCLK_saved)
    {
        TMSLDH();
    }
    else
    {
        TMSL();
    }

    TDIOWrite(0);

    TDIL();
    TDOsbw();    //ExitTCLK
    TCLK_saved = false;
}

//----------------------------------------------------------------------------
//! \brief Set TCLK in Spy-Bi-Wire mode
//! \details enters with TCLK_saved and exits with TCLK = 1
void SetTCLK_sbw(void)
{
   if (TCLK_saved)
   {
        TMSLDH();
   }
   else
   {
        TMSL();
   }

   TDIOWrite(1);

   TDIH();
   TDOsbw();    //ExitTCLK
   TCLK_saved = true;
}

//----------------------------------------------------------------------------
//! \brief Shift a value into TDI (MSB first) and simultaneously shift out a 
//! value from TDO (MSB first).
//! \param Format (number of bits shifted, 8 (F_BYTE), 16 (F_WORD), 
//! 20 (F_ADDR) or 32 (F_LONG))
//! \param Data (data to be shifted into TDI)
//! \return unsigned long (scanned TDO value)
unsigned long AllShifts(word Format, unsigned long Data)
{
   unsigned long TDOword = 0x00000000;
   unsigned long MSB = 0x00000000;
   word i;

   switch(Format)
   {
   case F_BYTE: MSB = 0x00000080;
     break;
   case F_WORD: MSB = 0x00008000;
     break;
   case F_ADDR: MSB = 0x00080000;
     break;
   case F_LONG: MSB = 0x80000000;
     break;
   default: // this is an unsupported format, function will just return 0
     return TDOword;
   }
   // shift in bits
   for (i = Format; i > 0; i--)
   {
        if (i == 1)                     // last bit requires TMS=1; TDO one bit before TDI
        {
          ((Data & MSB) == 0) ? TMSH_TDIL_TDOrd() : TMSH_TDIH_TDOrd();
        }
        else
        {
          ((Data & MSB) == 0) ? TMSL_TDIL_TDOrd() : TMSL_TDIH_TDOrd();
        }
        Data <<= 1;
        if (tdo_bit)
            TDOword++;
        if (i > 1)
            TDOword <<= 1;               // TDO could be any port pin
   }
   TMSH_TDIH();                         // update IR
   if (TCLK_saved)
   {
        TMSL_TDIH();
   }
   else
   {
        TMSL_TDIL();
   }

   // de-scramble bits on a 20bit shift
   if(Format == F_ADDR)
   {
     TDOword = ((TDOword << 16) + (TDOword >> 4)) & 0x000FFFFF;
   }
   
   return(TDOword);
}


//----------------------------------------------------------------------------
//! \brief Function for shifting a given 16-bit word into the JTAG data
//! register through TDI.
//! \param[in] word data (16-bit data, MSB first)
//! \return word (value is shifted out via TDO simultaneously)
word DR_Shift16(word data)
{
#ifdef SPYBIWIRE_MODE
    // JTAG FSM state = Run-Test/Idle
    if (TCLK_saved)
    {
        TMSH_TDIH();
    }
    else
    {
        TMSH_TDIL();
    }
    // JTAG FSM state = Select DR-Scan
    TMSL_TDIH();
    // JTAG FSM state = Capture-DR
    TMSL_TDIH();
#else
    // JTAG FSM state = Run-Test/Idle
    SetTMS();
    ClrTCK();
    SetTCK();

    // JTAG FSM state = Select DR-Scan
    ClrTMS();
    ClrTCK();
    SetTCK();
    // JTAG FSM state = Capture-DR
    ClrTCK();
    SetTCK();
#endif
    // JTAG FSM state = Shift-DR, Shift in TDI (16-bit)
    return(AllShifts(F_WORD, data));
    // JTAG FSM state = Run-Test/Idle
}



//----------------------------------------------------------------------------
//! \brief Reset target JTAG interface and perform fuse-HW check.
void ResetTAP(void)
{
    word i;

#ifdef SPYBIWIRE_MODE
    // Reset JTAG FSM
    for (i = 6; i > 0; i--)
    {
        TMSH_TDIH();
    }
    // JTAG FSM is now in Test-Logic-Reset
    TMSL_TDIH();                 // now in Run/Test Idle
#else
    // process TDI first to settle fuse current
    SetTDI();
    SetTMS();
    SetTCK();

    // Reset JTAG FSM
    for (i = 6; i > 0; i--)
    {
        ClrTCK();
        SetTCK();
    }
    // JTAG FSM is now in Test-Logic-Reset
    ClrTCK();
    ClrTMS();
    SetTCK();
    ClrTCK();    
    SetTCK();
    ClrTCK();    
    // JTAG FSM is now in Run-Test/IDLE
#endif
}


//----------------------------------------------------------------------------
//! \brief Function for shifting a new instruction into the JTAG instruction
//! register through TDI (MSB first, but with interchanged MSB - LSB, to
//! simply use the same shifting function, Shift(), as used in DR_Shift16).
//! \param[in] byte Instruction (8bit JTAG instruction, MSB first)
//! \return word TDOword (value shifted out from TDO = JTAG ID)
word IR_Shift(byte instruction)
{
#ifdef SPYBIWIRE_MODE
    // JTAG FSM state = Run-Test/Idle
    if (TCLK_saved)
    {
        TMSH_TDIH();
    }
    else
    {
        TMSH_TDIL();
    }
    // JTAG FSM state = Select DR-Scan
    TMSH_TDIH();

    // JTAG FSM state = Select IR-Scan
    TMSL_TDIH();
    // JTAG FSM state = Capture-IR
    TMSL_TDIH();
#else
    // JTAG FSM state = Run-Test/Idle
    SetTMS();
    ClrTCK();
    SetTCK();
    // JTAG FSM state = Select DR-Scan
    ClrTCK();
    SetTCK();

    // JTAG FSM state = Select IR-Scan
    ClrTMS();
    ClrTCK();
    SetTCK();
    // JTAG FSM state = Capture-IR
    ClrTCK();
    SetTCK();
#endif
    // JTAG FSM state = Shift-IR, Shift in TDI (8-bit)
    return(AllShifts(F_BYTE, instruction));
    // JTAG FSM state = Run-Test/Idle
}


//----------------------------------------------------------------------------
//! \brief Function to start the JTAG communication - RST line high - device starts
//! code execution   
void EntrySequences_RstHigh_SBW()
{
    TSTWrite(0);    //1
    DelayMs(4); // reset TEST logic

    RSTWrite(1);    //2
    
    TSTWrite(1);    //3
    DelayMs(20); // activate TEST logic

    // phase 1
    RSTWrite(1);    //4
    DelayUs(60);

    // phase 2 -> TEST pin to 0, no change on RST pin
    // for Spy-Bi-Wire
    TSTWrite(0);
    // phase 3
    DelayUs(1);
    // phase 4 -> TEST pin to 1, no change on RST pin
    // for Spy-Bi-Wire
    TSTWrite(1);
    DelayUs(60);

    // phase 5
    DelayMs(5);
}

//! \brief Function to start the SBW communication - RST line low - device do not 
//! start code execution   
void EntrySequences_RstLow_SBW()
{
    TSTWrite(0);                //1
    DelayMs(1);       // reset TEST logic
    
    RSTWrite(0);                //2
    DelayMs(50);
      
    TSTWrite(1);                //3
    DelayMs(100);     // activate TEST logic

    // phase 1
    RSTWrite(1);                //4
    DelayUs(40);

    // phase 2 -> TEST pin to 0, no change on RST pin
    // for Spy-Bi-Wire
    TSTWrite(0);                  //5
    DelayUs(1);
    // phase 4 -> TEST pin to 1, no change on RST pin
    // for Spy-Bi-Wire
    TSTWrite(1);      //7
    DelayUs(40);
    DelayMs(5);
}

//! \brief Function to start the JTAG communication - RST line high - device starts
//! code execution   
void EntrySequences_RstHigh_JTAG()
{
    TSTWrite(0);    //1
    DelayMs(4); // reset TEST logic

    RSTWrite(1);    //2
    
    TSTWrite(1);    //3
    DelayMs(20); // activate TEST logic

    // phase 1
    RSTWrite(0);    //4
    DelayUs(60);

    // phase 2 -> TEST pin to 0, no change on RST pin
    // for 4-wire JTAG clear Test pin
    TSTWrite(0);  //5

    // phase 3
    DelayUs(1);

    // phase 4 -> TEST pin to 1, no change on RST pin
    // for 4-wire JTAG
    TSTWrite(1);//7
    DelayUs(60);

    // phase 5
    RSTWrite(1);
    DelayMs(5);
}

//! \brief Function to start the JTAG communication - RST line low - device do not 
//! start code execution   
void EntrySequences_RstLow_JTAG()
{
    TSTWrite(0);                    //1    
    DelayMs(4);                  //reset TEST logic
    
    RSTWrite(0);                    //2
    DelayMs(50);
    
    TSTWrite(1);                   //3
    DelayMs(50);                 //activate TEST logic
               
    RSTWrite(0);                   //4
    DelayUs(40);

     // for 4-wire JTAG clear Test pin Test(0)   
    TSTWrite(0);                   //5
    DelayUs(2);

    // for 4-wire JTAG -dry  Reset(0)
    RSTWrite(0);                          
    DelayUs(2);

    // 4-wire JTAG - Test (1)
    TSTWrite(1);
    DelayMs(5);
    
    RSTWrite(1);
}



//----------------------------------------------------------------------------
//! \brief Write a 16bit value into the JTAG mailbox system.
//! The function timeouts if the mailbox is not empty after a certain number
//! of retries.
//! \param[in] word dataX (data to be shifted into mailbox)
short i_WriteJmbIn16(word dataX)
{
    unsigned short sJMBINCTL;
    unsigned short sJMBIN0;
    unsigned long Timeout = 0;
    sJMBIN0 = (unsigned short)(dataX & 0x0000FFFF);
    sJMBINCTL = INREQ;

    IR_Shift(IR_JMB_EXCHANGE); 
    do
    {
        Timeout++;
        if(Timeout >= 3000)
        {
            return STATUS_ERROR;
        }
    }
    while(!(DR_Shift16(0x0000) & IN0RDY) && Timeout < 3000);
    if(Timeout < 3000)
    {
        DR_Shift16(sJMBINCTL);
        DR_Shift16(sJMBIN0);
    }
    return STATUS_OK;
}



//----------------------------------------------------------------------------
//! \brief Start JTAG communication in JSBW mode.
//! \param byte states (reset state)
void StartJtagJSbw(byte states)
{
    // reset TEST logic  
    TSTWrite(0);
    DelayMs(20);             // delay 20ms
    
    if(states == RSTLOW_SBW || states == RSTLOW_JTAG)
    {   
        // Set Reset pin 0
        RSTWrite(0);
    }
    else
    {   
        // Set Reset pin = 1 
        RSTWrite(1);
    }  

    TSTWrite(1);
    // activate TEST logic
    DelayMs(25); 

    // phase 1
    if(states == RSTLOW_JTAG || states == RSTHIGH_JTAG)
    {
        //Set Reset pin =0 
        RSTWrite(0);
    }
    else
    {
        RSTWrite(1);
    }  
    DelayUs(40); 
    
    // phase 2 -> TEST pin to 0, no change on RST pin
    if(states == RSTLOW_SBW || states == RSTHIGH_SBW)
    { 
        // for Spy-Bi-Wire
      //  JTAGOUT &= ~SBWCLK;
    }
    else
    { 
        // for 4-wire JTAG
        TSTWrite(0);
    }
    
    // phase 3
    if(states == RSTLOW_JTAG)
    {
        RSTWrite(1);
    }
    DelayUs(1); 
    
    // phase 4 -> TEST pin to 1, no change on RST pin
    if(states == RSTLOW_SBW || states == RSTHIGH_SBW)
    { 
        // for Spy-Bi-Wire
     //   JTAGOUT |=   SBWCLK;
    }
    else
    { 
        // for 4-wire JTAG
        TSTWrite(1);
    }
    DelayUs(40); 
    
    // phase 5
    if(states == RSTHIGH_JTAG)
    {
        RSTWrite(1);
    }
    DelayMs(5);    
}


//----------------------------------------------------------------------------
//! \brief Reset target JTAG interface and perform fuse-HW check.
void jResetJtagTap(void)
{
    word i;  
    // Check Fuse, Reset JTAG FSM
    for (i = 6; i > 0; i--)      // 6 is nominal
    {
        TMSH_TDIH();
    }
    // JTAG FSM is now in Test-Logic-Reset
    TMSL_TDIH();                 // now in Run/Test Idle
}   

//----------------------------------------------------------------------------
//! \brief Shift a value into TDI (MSB first) and simultaneously shift out a 
//! value from TDO (MSB first).
//! \param word Format (number of bits shifted, 8 (F_BYTE), 16 (F_WORD), 
//! 20 (F_ADDR) or 32 (F_LONG))
//! \param long Data (data to be shifted into TDI)
//! \return unsigned long (scanned TDO value)
long jsbw_Shift(word Format, long Data)
{
    return AllShifts(Format, Data);
}

//----------------------------------------------------------------------------
//! \brief Function for shifting a new instruction into the JTAG instruction
//! register through JSBW (MSB first, but with interchanged MSB - LSB, to
//! simply use the same shifting function Shift()).
//! \param instruction (8 bit JTAG instruction)
//! \return word (TDOword - value shifted out from TDO: JTAG identification)
long jsbw_IR_Shift(byte instruction)
{
    // JTAG FSM state = Select DR-Scan
    TMSH_TDIH();

    // JTAG FSM state = Select IR-Scan
    TMSL_TDIH();
    // JTAG FSM state = Capture-IR
    TMSL_TDIH();
    // JTAG FSM state = Shift-IR, Shift in TDI (8-bit)
    return(jsbw_Shift(F_BYTE, instruction));
    // JTAG FSM state = Run-Test/Idle
}

//----------------------------------------------------------------------------
//! \brief Function for shifting data into the JTAG data register through JSBW 
//! (MSB first, but with interchanged MSB - LSB, to simply use the same shifting 
//! function Shift()).
//! \param data
//! \return word (TDOword - value shifted out from TDO: JTAG identification)
long jsbw_DR_Shift(long data)
{
    // JTAG FSM state = Run-Test/Idle
    if (TCLK_saved)
    {
        TMSH_TDIH();
    }
    else
    {
        TMSH_TDIL();
    }
    // JTAG FSM state = Select DR-Scan
    TMSL_TDIH();
    // JTAG FSM state = Capture-DR
    TMSL_TDIH();        
    // JTAG FSM state = Shift-DR, Shift in TDI (16-bit)
    return(jsbw_Shift(F_WORD, data));
    // JTAG FSM state = Run-Test/Idle
}

//----------------------------------------------------------------------------
//! \brief Function for applying the magic pattern via JSBW.
void JsbwMagicPattern(void)
{
    jsbw_IR_Shift(IR_JMB_EXCHANGE);
    DelayMs(10);       
    jsbw_DR_Shift(0x0001);
    DelayMs(10);    
    jsbw_DR_Shift(STOP_DEVICE);    
    DelayMs(15);        
}


//----------------------------------------------------------------------------
//! \brief Releases the JSBW logic.
void jRelease(void)
{
    RSTWrite(0);
    DelayMs(1);
    TSTWrite(0);
}

//----------------------------------------------------------------------------
//! \brief Set JTAG pins to output direction - from REP430F to target
void configure_IO_JTAG(void)
{
    TSTDir(1);
    RSTDir(1);
}

//----------------------------------------------------------------------------
//! \brief Function for resetting the JTAG lock via JSBW.
void jsbwJtagUnlock(void)
{    
    jsbw_IR_Shift(IR_TEST_3V_REG);
    DelayMs(10);  
    jsbw_DR_Shift(0x4020);
    DelayMs(10);  
}


//----------------------------------------------------------------------------
//! \brief Function to enable JTAG communication with a target. Use JSBW mode
//!  if device is in LPM5 mode.
//! \return word (JTAG_ID91(0x91) if connection was established successfully, 
//! invalid JTAG ID (0x1) otherwise)
word magicPattern(void)
{
    volatile word deviceJtagID = 0;
    
    // Enable the JTAG interface to the device.
    ConnectJTAG();     
    // Apply again 4wire/SBW entry Sequence.
    // set ResetPin = 0
    if(INTERFACE == SPYBIWIRE_IF)
    {
        EntrySequences_RstLow_SBW();
    }
    else
    {
        EntrySequences_RstLow_JTAG();
    }       
    // reset TAP state machine -> Run-Test/Idle
    ResetTAP();  
    // feed JTAG mailbox with magic pattern
    if(i_WriteJmbIn16(STOP_DEVICE) == STATUS_OK)
    {                  
        // Apply again 4wire/SBW entry Sequence.
        if(INTERFACE == SPYBIWIRE_IF)
        {
            EntrySequences_RstHigh_SBW();
        }
        else
        {
            EntrySequences_RstHigh_JTAG();
        }
        ResetTAP();  // reset TAP state machine -> Run-Test/Idle

        deviceJtagID = (word)IR_Shift(IR_CNTRL_SIG_CAPTURE);

        if(deviceJtagID == JTAG_ID91)
        {
            // if Device is in LPM.x5 -> reset IO lock of JTAG pins and Configure it for debug
            IR_Shift(IR_TEST_3V_REG);  
            DR_Shift16(0x4020);
        }
        else if(deviceJtagID == JTAG_ID99)
        {
            IR_Shift(IR_TEST_3V_REG); 
            DR_Shift16(0x40A0);
        }
        return deviceJtagID;
    }
    // if Device is in LPM.x5 -> reset IO lock of JTAG pins and Configure it for debug
#ifdef LPM5_ACTIVATED
    {
#ifdef SPYBIWIREJTAG_IF // run 2 wire mode of 4 wire selection because 4wire pins are locked by JTAG lock
      
        ConnectJTAG();
        StartJtagJSbw(RSTLOW_SBW);        
        jResetJtagTap();
        JsbwMagicPattern();
        jRelease();          
        DelayMs(60); 
        
        // reset JTAG lock
        configure_IO_JTAG();                    
        StartJtagJSbw(RSTHIGH_SBW);   
        jResetJtagTap();
        jsbwJtagUnlock();
        DelayMs(60); 
        
        configure_IO_JTAG();
        EntrySequences_RstHigh_JTAG();             
        ResetTAP();  // reset TAP state machine -> Run-Test/Idle    
        DelayMs(60); 
        deviceJtagID = (word)IR_Shift(IR_CNTRL_SIG_CAPTURE);
        if(deviceJtagID == JTAG_ID91 || deviceJtagID == JTAG_ID99)
        {
            return deviceJtagID;
        }
#endif
    } 
#endif
    return 1;  // return 1 as an invalid JTAG ID
}


//----------------------------------------------------------------------------
//! \brief Function to determine & compare core identification info 
//! \return word (STATUS_OK if correct JTAG ID was returned, STATUS_ERROR 
//! otherwise)
word GetCoreID (void)
{
    word i;
    volatile word JtagId = 0;  //initialize JtagId with an invalid value
    for (i = 0; i < MAX_ENTRY_TRY; i++)
    {
        // release JTAG/TEST signals to safely reset the test logic
        StopJtag();        
        // establish the physical connection to the JTAG interface
        ConnectJTAG();
        // Apply again 4wire/SBW entry Sequence. 
        // set ResetPin =1    
        if(INTERFACE == SPYBIWIRE_IF)
        {
            EntrySequences_RstHigh_SBW();
        }
        else
        {
            EntrySequences_RstHigh_JTAG();
        }          
        // reset TAP state machine -> Run-Test/Idle
        ResetTAP();  
        // shift out JTAG ID
        JtagId = (word)IR_Shift(IR_CNTRL_SIG_CAPTURE);  
         
        // break if a valid JTAG ID is being returned
        if((JtagId == JTAG_ID91) || (JtagId == JTAG_ID99) || (JtagId == JTAG_ID98))
        {
            return JtagId;
        }
    }
    if(i >= MAX_ENTRY_TRY)
    {
    // if connected device is MSP4305438 JTAG Mailbox is not usable
#ifdef ACTIVATE_MAGIC_PATTERN
        for(i = 0; i < MAX_ENTRY_TRY; i++)
        {
            // if no JTAG ID is returns -> apply magic pattern to stop user cd excecution 
            JtagId = magicPattern();
            if((JtagId == JTAG_ID91) || (JtagId == JTAG_ID99) || (JtagId == JTAG_ID98))
            {
                return JtagId;
            }
        }
        // For MSP430F5438 family mailbox is not functional in reset state.
        // Because of this issue the magicPattern is not usable on MSP430F5438 family devices
#endif
        return(STATUS_ERROR);
    }
    if((JtagId == JTAG_ID91) || (JtagId == JTAG_ID99) || (JtagId == JTAG_ID98))                        //****************************
    {
        return(STATUS_OK);
    }
    else
    {
        return(STATUS_ERROR);
    } 
}
